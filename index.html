<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ°´å“¥ (Shuige) - ç²’å­è¯­éŸ³ç‰ˆ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
            color: white;
        }

        /* ç”»å¸ƒåŒºåŸŸ */
        #canvas-container {
            position: relative;
            width: 400px;
            height: 400px;
            border-radius: 50%;
            /* ç»™æ•´ä¸ªåŒºåŸŸåŠ ä¸€ç‚¹ç¯å¢ƒå…‰ */
            background: radial-gradient(circle, rgba(0, 242, 254, 0.05) 0%, transparent 70%);
        }
        canvas {
            display: block;
        }

        /* å¯¹è¯æ°”æ³¡ */
        #chat-bubble {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: rgba(255, 255, 255, 0.9);
            padding: 12px 25px;
            border-radius: 20px;
            font-size: 16px;
            color: #333;
            opacity: 0;
            transition: all 0.4s;
            pointer-events: none;
            box-shadow: 0 0 20px rgba(0, 242, 254, 0.3);
            font-weight: bold;
            white-space: nowrap;
            z-index: 10;
        }
        #chat-bubble.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* åº•éƒ¨æ§åˆ¶åŒº */
        #controls {
            position: fixed;
            bottom: 40px;
            display: flex;
            gap: 15px;
            z-index: 20;
            align-items: center;
        }

        /* è¯­éŸ³æŒ‰é’® */
        #mic-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #1a1a1a;
            border: 2px solid #00f2fe;
            color: #00f2fe;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 242, 254, 0.3);
            transition: all 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #mic-btn:active, #mic-btn.listening {
            background: #00f2fe;
            color: #000;
            box-shadow: 0 0 30px #00f2fe;
            transform: scale(0.95);
        }
        #mic-btn.listening {
            animation: pulse 1.5s infinite;
        }

        /* æ–‡å­—è¾“å…¥æ¡† (å¤‡ç”¨) */
        input {
            padding: 12px 20px;
            border-radius: 30px;
            border: 1px solid #333;
            background: rgba(255,255,255,0.1);
            color: white;
            outline: none;
            width: 200px;
            backdrop-filter: blur(5px);
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 242, 254, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(0, 242, 254, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 242, 254, 0); }
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <div id="chat-bubble">æˆ‘æ˜¯æ°´å“¥ï¼ŒæŒ‰ä½éº¦å…‹é£è¯´è¯ã€‚</div>
        <canvas id="particleCanvas"></canvas>
    </div>

    <div id="controls">
        <input type="text" id="text-input" placeholder="è¾“å…¥æˆ–ç‚¹å‡»éº¦å…‹é£...">
        <button id="mic-btn" title="ç‚¹å‡»å¼€å§‹è¯´è¯">ğŸ™ï¸</button>
    </div>

    <script>
        // --- 1. è¯­éŸ³è¯†åˆ«ç³»ç»Ÿ (Web Speech API) ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const micBtn = document.getElementById('mic-btn');
        const textInput = document.getElementById('text-input');
        let recognition;

        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.lang = 'zh-CN'; // è®¾ç½®ä¸­æ–‡
            recognition.continuous = false; // è¯´å®Œä¸€å¥è‡ªåŠ¨åœæ­¢
            recognition.interimResults = false;

            recognition.onstart = () => {
                micBtn.classList.add('listening');
                showBubble("æ­£åœ¨å¬...");
            };

            recognition.onend = () => {
                micBtn.classList.remove('listening');
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                textInput.value = transcript;
                processCommand(transcript); // ç›´æ¥å¤„ç†ç»“æœ
            };

            micBtn.onclick = () => {
                recognition.start();
            };
        } else {
            micBtn.style.display = 'none'; // ä¸æ”¯æŒè¯­éŸ³åˆ™éšè—æŒ‰é’®
            showBubble("æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³ï¼Œè¯·æ‰“å­—ã€‚");
        }

        // é”®ç›˜å›è½¦æ”¯æŒ
        textInput.addEventListener('keypress', (e) => {
            if(e.key === 'Enter') processCommand(textInput.value);
        });


        // --- 2. ç²’å­ç³»ç»Ÿ (Canvas Physics) ---
        const canvas = document.getElementById('particleCanvas');
        const ctx = canvas.width = 400;
        const cty = canvas.height = 400;
        const ctx2d = canvas.getContext('2d');

        // ç²’å­é…ç½®
        const particleCount = 250;
        const particles = [];
        let state = "idle"; // idle, wave, sit, stand, angry, scatter
        let time = 0;

        class Particle {
            constructor() {
                // åˆå§‹ä½ç½®ï¼šå±å¹•ä¸­å¿ƒéšæœº
                this.x = 200 + (Math.random() - 0.5) * 20;
                this.y = 200 + (Math.random() - 0.5) * 20;
                // ç›®æ ‡ä½ç½®
                this.tx = this.x;
                this.ty = this.y;
                // é€Ÿåº¦å’Œæ‘©æ“¦
                this.vx = 0;
                this.vy = 0;
                this.friction = 0.92;
                this.speed = Math.random() * 0.05 + 0.02;
                this.size = Math.random() * 3 + 1;
                this.color = `rgba(0, 242, 254, ${Math.random() * 0.5 + 0.5})`;
            }

            update(targetX, targetY, loose) {
                // è®¡ç®—å»å¾€ç›®æ ‡ç‚¹çš„åŠ›
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                
                // ç®€å•çš„å¼¹ç°§ç‰©ç†
                this.vx += dx * this.speed;
                this.vy += dy * this.speed;
                
                // åŠ ä¸Šä¸€ç‚¹éšæœºæ‰°åŠ¨ï¼ˆå¸ƒæœ—è¿åŠ¨ï¼‰ï¼Œè®©å®ƒçœ‹èµ·æ¥åƒæ°”ä½“/èƒ½é‡
                if (loose) {
                    this.vx += (Math.random() - 0.5) * 2;
                    this.vy += (Math.random() - 0.5) * 2;
                }

                this.vx *= this.friction;
                this.vy *= this.friction;

                this.x += this.vx;
                this.y += this.vy;
            }

            draw() {
                ctx2d.fillStyle = this.color;
                ctx2d.beginPath();
                ctx2d.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx2d.fill();
            }
        }

        // åˆå§‹åŒ–ç²’å­
        for (let i = 0; i < particleCount; i++) {
            particles.push(new Particle());
        }

        // --- åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            ctx2d.clearRect(0, 0, 400, 400); // æ¸…ç©ºç”»å¸ƒ
            time += 0.05;

            // æ ¹æ®çŠ¶æ€è®¡ç®—ç²’å­çš„ç›®æ ‡ä½ç½®
            particles.forEach((p, index) => {
                let tx, ty, loose = true;

                if (state === "idle") {
                    // æ ¸å¿ƒçƒä½“å‘¼å¸
                    const angle = index; 
                    const r = 50 + Math.sin(time + index) * 5; // å‘¼å¸åŠå¾„
                    tx = 200 + Math.cos(angle) * r;
                    ty = 200 + Math.sin(angle) * r;
                } 
                else if (state === "wave") {
                    // æŒ¥æ‰‹åŠ¨ä½œ
                    if (index < 50) { 
                        // å‰50ä¸ªç²’å­ç»„æˆä¸€åªæ‰‹
                        // æ‰‹åšæ­£å¼¦æ‘†åŠ¨
                        const waveX = 280 + Math.cos(time * 3) * 20;
                        const waveY = 180 + Math.sin(time * 3) * 40;
                        tx = waveX + (Math.random()-0.5)*15;
                        ty = waveY + (Math.random()-0.5)*15;
                        p.color = "rgba(255, 255, 255, 0.9)"; // æ‰‹å˜äº®
                    } else {
                        // å‰©ä¸‹çš„ä¿æŒèº«ä½“
                        const angle = index;
                        const r = 50;
                        tx = 190 + Math.cos(angle) * r;
                        ty = 200 + Math.sin(angle) * r;
                        p.color = "rgba(0, 242, 254, 0.6)";
                    }
                }
                else if (state === "stand") {
                    // ç«™ç«‹ï¼šåˆ†ä¸¤ç»„åšè…¿
                    if (index < 40) { // å·¦è…¿
                        tx = 180 + (Math.random()-0.5)*10;
                        ty = 280 + (Math.random()-0.5)*40; // é•¿æ¡å½¢
                    } else if (index < 80) { // å³è…¿
                        tx = 220 + (Math.random()-0.5)*10;
                        ty = 280 + (Math.random()-0.5)*40;
                    } else { // èº«ä½“ä¸Šç§»
                        const angle = index;
                        const r = 50;
                        tx = 200 + Math.cos(angle) * r;
                        ty = 160 + Math.sin(angle) * r;
                    }
                }
                else if (state === "scatter") {
                    // ç‚¸å¼€
                    tx = 200 + (Math.random()-0.5) * 350;
                    ty = 200 + (Math.random()-0.5) * 350;
                    loose = false;
                }
                else if (state === "angry") {
                    // æ„¤æ€’éœ‡åŠ¨
                    const r = 60;
                    tx = 200 + Math.cos(index) * r + (Math.random()-0.5)*10;
                    ty = 200 + Math.sin(index) * r + (Math.random()-0.5)*10;
                    p.color = `rgba(255, ${Math.random()*50}, 0, 0.8)`; // å˜çº¢
                }

                p.update(tx, ty, loose);
                p.draw();
            });

            requestAnimationFrame(animate);
        }
        animate();


        // --- 3. é€»è¾‘æ§åˆ¶ä¸­å¿ƒ (æ°´å“¥çš„å¤§è„‘) ---
        const bubble = document.getElementById('chat-bubble');
        let bubbleTimer;
        let lastAction = "";
        let repeatCount = 0;
        let idleTimer = null;
        let isWaiting = false;

        function processCommand(rawText) {
            if (!rawText) return;
            const text = rawText.toLowerCase().trim();

            // é‡ç½®è®¡æ—¶å™¨
            if (idleTimer) clearTimeout(idleTimer);

            // 1. æ˜¯å¦å–Šäº†åå­—
            if (text.includes("æ°´å“¥") || isWaiting) {
                let cmd = text.replace("æ°´å“¥", "").replace("ï¼Œ", "").replace("ã€‚", "").trim();

                // åªæœ‰åå­—
                if (!cmd) {
                    isWaiting = true;
                    showBubble("æˆ‘åœ¨ã€‚è¯·è®²ï¼Ÿ");
                    setState("idle");
                    // 5ç§’ååæ§½
                    idleTimer = setTimeout(() => {
                        showBubble("æ²¡äº‹å–Šæˆ‘å¹²å•¥ï¼Ÿæˆ‘å¾ˆå¿™çš„ã€‚");
                        setState("angry"); // å‡è£…ç”Ÿæ°”ä¸€ä¸‹
                        setTimeout(() => setState("idle"), 2000);
                        isWaiting = false;
                    }, 5000);
                    return;
                }

                isWaiting = false; // æ”¶åˆ°æŒ‡ä»¤

                // 2. æ£€æŸ¥é‡å¤ (æ€§æ ¼ç³»ç»Ÿ)
                if (cmd === lastAction) {
                    repeatCount++;
                    if (repeatCount >= 3) {
                        showBubble("æä»€ä¹ˆï¼Ÿè¿™ä¹ˆæ²¡æœ‰æƒ³è±¡åŠ›ï¼Ÿ");
                        setState("angry");
                        setTimeout(() => setState("idle"), 2000);
                        return;
                    }
                } else {
                    lastAction = cmd;
                    repeatCount = 1;
                }

                // 3. æŒ‡ä»¤è§£æä¸æ‰§è¡Œ
                handleSpecificCommand(cmd);

            } else {
                showBubble("è¯·å…ˆå–Šæˆ‘çš„åå­—ï¼šæ°´å“¥ã€‚");
            }
        }

        function handleSpecificCommand(cmd) {
            // ä½ å¥½ -> æŒ¥æ‰‹
            if (cmd.includes("ä½ å¥½") || cmd.includes("hello") || cmd.includes("hi")) {
                showBubble("ä½ å¥½å‘€ï¼(æŒ¥æ‰‹)");
                setState("wave");
                setTimeout(() => setState("idle"), 3000); // 3ç§’åæ¢å¤
            }
            // ç«™èµ·æ¥
            else if (cmd.includes("ç«™") || cmd.includes("èµ·ç«‹")) {
                showBubble("å˜¿å’»... ç«™èµ·æ¥äº†ï¼");
                setState("stand");
            }
            // åä¸‹
            else if (cmd.includes("å") || cmd.includes("ä¼‘æ¯")) {
                showBubble("å¥½çš„ï¼Œå˜å›åœ†çƒã€‚");
                setState("idle");
            }
            // ç‚¸å¼€/æ¶ˆå¤±
            else if (cmd.includes("ç‚¸") || cmd.includes("æ•£") || cmd.includes("æ¶ˆå¤±")) {
                showBubble("å˜­ï¼ï¼ï¼");
                setState("scatter");
                setTimeout(() => setState("idle"), 2000);
            }
            // ç”Ÿæ°”
            else if (cmd.includes("ç”Ÿæ°”") || cmd.includes("çº¢")) {
                showBubble("æˆ‘å¾ˆç”Ÿæ°”ï¼åæœå¾ˆä¸¥é‡ï¼");
                setState("angry");
            }
            // å¤¸å¥–
            else if (cmd.includes("å¸…") || cmd.includes("å‰å®³") || cmd.includes("æ£’")) {
                showBubble("ä½è°ƒï¼Œä½è°ƒï¼Œä¹Ÿå°±ä¸–ç•Œç¬¬ä¸‰ã€‚");
                // å…´å¥‹åœ°é—ªçƒ (é€šè¿‡ idle é…åˆé¢œè‰²å˜åŒ–ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†)
                setState("wave"); 
            }
            else {
                showBubble("æ²¡å¬æ‡‚ \"" + cmd + "\"ï¼Œèƒ½æ¢ä¸ªè¯´æ³•å—ï¼Ÿ");
            }
        }

        // çŠ¶æ€åˆ‡æ¢è¾…åŠ©
        function setState(newState) {
            state = newState;
            // çŠ¶æ€åˆ‡æ¢æ—¶ï¼Œé‡ç½®ç²’å­é¢œè‰² (é™¤äº†ç‰¹æ®ŠçŠ¶æ€)
            particles.forEach(p => {
                if (newState !== "angry") {
                    p.color = `rgba(0, 242, 254, ${Math.random() * 0.5 + 0.5})`;
                }
            });
        }

        function showBubble(text) {
            bubble.innerText = text;
            bubble.classList.add("show");
            if (bubbleTimer) clearTimeout(bubbleTimer);
            bubbleTimer = setTimeout(() => {
                bubble.classList.remove("show");
            }, 3000);
        }

    </script>
</body>
</html>
