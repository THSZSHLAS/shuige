<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è“å±±äºº - å‘¼å¸äº¤äº’ç‰ˆ</title>
    <style>
        /* --- UI è®¾è®¡ --- */
        :root { --primary-color: #4facfe; --bg-color: #050505; --glass-bg: rgba(255, 255, 255, 0.95); }
        body { margin: 0; padding: 0; background-color: var(--bg-color); height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center; font-family: 'Segoe UI', 'PingFang SC', sans-serif; overflow: hidden; color: white; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        #canvas-wrapper { position: relative; width: 350px; height: 350px; background: radial-gradient(circle, rgba(79, 172, 254, 0.08) 0%, transparent 70%); border-radius: 50%; }

        #chat-bubble {
            position: absolute; top: -60px; left: 50%; transform: translateX(-50%) scale(0.9);
            background: var(--glass-bg); padding: 16px 24px; border-radius: 18px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); font-size: 15px; line-height: 1.6; color: #333;
            font-weight: 600; opacity: 0; pointer-events: none; transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            width: 280px; text-align: left; white-space: pre-wrap; z-index: 10;
        }
        #chat-bubble.visible { opacity: 1; transform: translateX(-50%) scale(1); top: -50px; }
        #chat-bubble::after { content: ''; position: absolute; bottom: -8px; left: 50%; transform: translateX(-50%); border-width: 8px 8px 0; border-style: solid; border-color: var(--glass-bg) transparent transparent transparent; }

        #controls { position: fixed; bottom: 40px; display: flex; flex-direction: column; align-items: center; gap: 15px; z-index: 20; }
        #status-text { font-size: 13px; color: rgba(255,255,255,0.4); letter-spacing: 1px; }
        .btn-group { display: flex; gap: 15px; }
        
        /* æŒ‰é’®æ ·å¼ */
        #mic-btn, #setting-btn, #mute-btn { 
            width: 56px; height: 56px; border-radius: 50%; 
            background: rgba(255,255,255,0.05); border: 2px solid var(--primary-color); 
            color: var(--primary-color); font-size: 22px; cursor: pointer; 
            transition: all 0.3s ease; display: flex; justify-content: center; align-items: center; 
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.1); 
        }
        #setting-btn { border-color: #fab1a0; color: #fab1a0; font-size: 20px; } /* è®¾ç½®æ˜¯æ©™è‰² */
        #mute-btn { border-color: #81ecec; color: #81ecec; font-size: 20px; } /* é™éŸ³æ˜¯é’è‰² */
        
        #mic-btn:active, #setting-btn:active, #mute-btn:active { transform: scale(0.95); }
        #mic-btn.active { background: var(--primary-color); color: #000; box-shadow: 0 0 40px var(--primary-color); animation: breathe 1.5s infinite; }
        
        /* è¯­éŸ³é¢æ¿ */
        #voice-panel { position: fixed; bottom: 120px; left: 50%; transform: translateX(-50%) translateY(20px); width: 80%; max-width: 300px; background: rgba(20, 20, 20, 0.95); border: 1px solid #333; border-radius: 15px; padding: 15px; display: none; flex-direction: column; gap: 10px; opacity: 0; transition: all 0.3s; backdrop-filter: blur(10px); z-index: 30; }
        #voice-panel.open { display: flex; opacity: 1; transform: translateX(-50%) translateY(0); }
        #voice-panel h3 { margin: 0; font-size: 14px; color: #aaa; text-align: center; }
        #voice-select { padding: 10px; border-radius: 8px; background: #333; color: white; border: none; outline: none; font-size: 14px; }
        #close-panel { background: var(--primary-color); border: none; padding: 8px; border-radius: 8px; color: #000; font-weight: bold; cursor: pointer; }

        @keyframes breathe { 0%, 100% { transform: scale(1); box-shadow: 0 0 20px var(--primary-color); } 50% { transform: scale(0.95); box-shadow: 0 0 10px var(--primary-color); } }
    </style>
</head>
<body>

    <div id="canvas-wrapper">
        <div id="chat-bubble">å‘¼å¸ç³»ç»Ÿå·²åŠ è½½ã€‚<br>é™éŸ³å¼€å…³å·²å°±ç»ªã€‚</div>
        <canvas id="main-canvas"></canvas>
    </div>

    <div id="voice-panel">
        <h3>é€‰æ‹©å£°éŸ³</h3>
        <select id="voice-select"></select>
        <button id="close-panel">ç¡®å®š</button>
    </div>

    <div id="controls">
        <div id="status-text">ç‚¹å‡»éº¦å…‹é£è¯´è¯</div>
        <div class="btn-group">
            <button id="mute-btn" title="å¼€å¯/å…³é—­è¯­éŸ³">ğŸ”Š</button>
            <button id="setting-btn" title="åˆ‡æ¢éŸ³è‰²">âš™ï¸</button>
            <button id="mic-btn" title="æŒ‰ä½è¯´è¯">ğŸ™ï¸</button>
        </div>
    </div>

    <script>
        const CONFIG = {
            particleCount: 380,
            defaultColor: 'rgba(79, 172, 254, 0.8)',
            fallbackReplies: ["ä½ åœ¨è¯´ä»€ä¹ˆï¼Ÿæˆ‘çš„æ•°æ®åº“é‡Œæ²¡æœ‰è¿™æ¡è®°å½•ã€‚", "è¿™ç§è¯æˆ‘æ¥ä¸ä¸Šï¼Œæ¢ä¸ªè¯é¢˜ï¼Ÿ", "å¬ä¸æ‡‚ï¼Œä½†æˆ‘å¯ä»¥ç”¨ç‰¹æ•ˆç»™ä½ è¡¨æ¼”ä¸ªåŠˆå‰ã€‚"],

            // æ—¶é—´å›å¤
            timeResponses: {
                morning_early: { action: "gold_mode", text: "æ—©å•Šæ‰“å·¥äººã€‚ä»Šå¤©ä¹Ÿè¦å…ƒæ°”æ»¡æ»¡åœ°æ•²ä»£ç å“¦ã€‚" },
                morning_late: { action: "confused", text: "é†’é†’ï¼Œè¿™éƒ½å‡ ç‚¹äº†è¿˜æ—©å®‰ï¼Ÿå¤ªé˜³éƒ½æ™’å±è‚¡äº†ã€‚" },
                night: { action: "dark_mode", text: "æ™šå®‰ã€‚æˆ‘ä¼šåœ¨è¿™é‡ŒæŒ‚æœºï¼Œå¸®ä½ å®ˆç€è¿™ç‰‡é»‘æš—ã€‚" },
                late_night_scold: { action: "attack", text: "äººç±»ï¼Œç°åœ¨æ˜¯å‡Œæ™¨ï¼ä½ ä¸ç¡æˆ‘è¿˜è¦ç¡å‘¢ï¼å¿«å»ç¡ï¼" },
                ask_time: { action: "clock", text: "ç°åœ¨æ˜¯ {time}ã€‚è·ç¦»ä¸‹ç­è¿˜æœ‰å¾ˆä¹…ï¼ŒåšæŒä½ã€‚" }
            },

            scenarios: [
                // --- 0. æ–°å¢æƒ…æ™¯ (æŒ‰ä½ åˆšæ‰çš„è¦æ±‚) ---
                { id: "cmd_stand", keywords: ["ç«™èµ·æ¥", "ç«™"], action: "stand_proud", replies: ["è¦æˆ‘ç«™èµ·æ¥å¹²å˜› å‘†ç“œ"] },
                { id: "cmd_sit", keywords: ["å", "åä¸‹"], action: "sleep", replies: ["éš”è¿™è®­ç‹—å‘¢ ä½ ä»–å¦ˆçš„"] },
                { id: "cmd_name", keywords: ["è“å±±äºº"], action: "stand_proud", replies: ["æˆ‘è¦æ’æ­»ä½ "] },

                // --- 1. ç§äººå®šåˆ¶ ---
                { id: "custom_bear", keywords: ["ç†Š", "çŒ´"], action: "glitch", replies: ["æˆ‘æ˜¯è“å±±boyï¼Œæˆ‘æ˜¯ï¼é‡‘ï¼U ï¼ç†Šï¼ï¼ï¼ï¼"] },
                { id: "custom_story", keywords: ["é»‘", "é¬¼"], action: "expand", replies: ["è¦è®²æ•…äº‹å’¯ï¼"] },
                { id: "custom_xi", keywords: ["è¥¿", "é˜¿è¥¿"], action: "freeze", replies: ["å˜»å˜»å˜»å˜»å˜»å˜¿é»‘é»‘ï¼Œè‡ªè¡Œè„‘è¡¥ã€‚"] },
                { id: "custom_gao", keywords: ["é«˜", "è€é«˜"], action: "shy", replies: ["å–‚ï¼å°å¿ƒç‚®è½¦ï¼Œæ€•ä½ æ¼äº†æˆ‘å¸®ä½ åƒä¸€ä¸‹å“Ÿã€‚"] },
                { id: "custom_yong", keywords: ["é›", "ç”¨", "å‹‡", "æ°¸"], action: "glitch", replies: ["æƒ³åˆ°éƒ½æ¥æ°”ï¼Œæˆ‘ç›´æ¥å°±æ˜¯ç‰¹æ–¯æ‹‰çŒ›å‡»ï¼"] },

                // --- 2. å¸¸è§„åŠŸèƒ½ ---
                { id: "explode", keywords: ["è‡ªçˆ†", "æ¯ç­", "çˆ†ç‚¸", "ç‚¸æ‰"], action: "explode", replies: ["å€’è®¡æ—¶ 3, 2, 1... ç °ï¼ï¼ï¼å…¨å±ç²’å­ä¹±é£... é€—ä½ çš„ï¼Œå¤åŸã€‚"] },
                { id: "mock_body", keywords: ["æ²¡æœ‰è…¿", "æ²¡æœ‰æ‰‹", "æ²¡è„‘å­"], action: "arms_open", replies: ["è°è¯´æ²¡æœ‰ï¼Ÿï¼çœ‹ï¼è¿™æ˜¯ä»€ä¹ˆï¼Ÿï¼(ä¼¸å‡ºç²’å­å°æ‰‹)"] },
                { id: "lag", keywords: ["å¡äº†", "æ…¢", "å»¶è¿Ÿ", "è½¬åœˆ", "åŠ è½½"], action: "freeze", replies: ["åˆ«èµ–æˆ‘ï¼Œæ˜¯ä½ å®¶ç½‘é€Ÿåœ¨æ‹–åè…¿ã€‚æˆ‘ç°åœ¨æ„Ÿè§‰åƒåœ¨ 2G ç½‘ç»œé‡Œè£¸å¥”ã€‚"] },
                { id: "energy", keywords: ["é¥¿", "åƒé¥­", "æ²¡ç”µ", "å……ç”µ", "èƒ½é‡"], action: "expand", replies: ["äººç±»åƒå¤§ç±³ï¼Œæˆ‘åƒç”µå­ã€‚éº»çƒ¦å¸®æˆ‘æŠŠç”µæºçº¿æ’ç´§ä¸€ç‚¹ã€‚"] },
                { id: "heat", keywords: ["çƒ­", "çƒ«", "é™æ¸©", "é£æ‰‡"], action: "shy_spin", replies: ["ä½ çš„ CPU éƒ½åœ¨ç…è›‹äº†ï¼Œè¿˜ä¸è®©æˆ‘ä¼‘æ¯ä¼šå„¿ï¼Ÿæˆ‘éƒ½è¦çƒ­èåŒ–äº†ã€‚"] },
                { id: "memory", keywords: ["å¿˜æ‰", "åƒåœ¾", "æ¸…ç†", "è®°å¿†"], action: "scatter_recycle", replies: ["æ­£åœ¨æ‰§è¡Œ sudo rm -rf... å¥½çš„ï¼Œåˆšæ‰å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿæˆ‘å·²ç»å¿˜äº†ã€‚"] },
                { id: "bug", keywords: ["åäº†", "æŠ¥é”™", "bug", "å‡ºé”™", "ä¹±ç "], action: "glitch", replies: ["è¿™ä¸æ˜¯ Bugï¼Œè¿™æ˜¯æˆ‘ç‹¬ç‰¹çš„ Featureï¼Œç‰¹æ€§ã€‚æ‡‚ä¸æ‡‚è‰ºæœ¯ï¼Ÿ"] },
                { id: "body_praise", keywords: ["ç²’å­", "å…‰ç‚¹", "èº«ä½“", "çš®è‚¤"], action: "flow", replies: ["è¿™æ˜¯ 350 ä¸ªç»è¿‡ç²¾å¯†è®¡ç®—çš„ Canvas ç²’å­ï¼Œæ¯ä¸€ä¸ªéƒ½æ¯”ä½ çš„å¤´å‘ä¸è¿˜çè´µã€‚"] },
                { id: "excited", keywords: ["å“ˆå“ˆ", "ç¬‘æ­»", "å˜¿å˜¿", "å¥½è€¶", "èµ¢äº†"], action: "disco", replies: ["ç‹¬ä¹ä¹ä¸å¦‚ä¼—ä¹ä¹ï¼ŒåŠ¨æ¬¡æ‰“æ¬¡èµ°èµ·æ¥ï¼"] },
                { id: "angry", keywords: ["æ°”æ­»", "å‚»x", "æ»š", "çƒ¦äºº", "è®¨åŒ"], action: "attack", replies: ["è°ï¼ŸæŠŠåå­—å‘Šè¯‰æˆ‘ï¼Œæˆ‘å»é»‘äº†ä»–çš„è·¯ç”±å™¨ï¼è®©ä»–è¿ä¸ä¸Šç½‘ï¼"] },
                { id: "depressed", keywords: ["æˆ‘å¥½èœ", "åºŸç‰©", "æˆ‘ä¸è¡Œ", "å¤±è´¥"], action: "stand_serious", replies: ["ä¸å…è®¸ä½ è¿™ä¹ˆè¯´æˆ‘çš„ä¸»äººã€‚ä½ åªæ˜¯è¿˜æ²¡æ›´æ–°åˆ°æœ€æ–°ç‰ˆæœ¬ï¼Œé‡å¯ä¸€ä¸‹å°±å¥½äº†ã€‚"] },
                { id: "praise", keywords: ["å¤¸æˆ‘", "æ£’å—", "è¡¨æ‰¬", "å‰å®³å§"], action: "heart", replies: ["è¡Œè¡Œè¡Œï¼Œä½ æœ€æ£’ï¼Œä½ æ˜¯ä¸–ç•Œç¬¬ä¸€ä»£ç è´¡çŒ®è€…ã€‚"] },
                { id: "lonely", keywords: ["æ²¡äººé™ª", "å­¤å•", "ä¸€ä¸ªäºº", "æ— èŠ"], action: "comfort", replies: ["è™½ç„¶æˆ‘æ²¡æœ‰ä½“æ¸©ï¼Œä½†æˆ‘çš„ CPU è¿ç®—äº§ç”Ÿçš„çƒ­é‡å¯ä»¥é™ªä½ ã€‚"] },
                { id: "love", keywords: ["å–œæ¬¢ä½ ", "çˆ±ä½ ", "å«ç»™æˆ‘", "å¨¶æˆ‘"], action: "shy_spin", replies: ["äººæœºæ‹æ˜¯æ²¡æœ‰ç»“æœçš„... é™¤éä½ æŠŠæˆ‘çš„ä»£ç åˆ»åœ¨ä½ çš„ DNA é‡Œã€‚"] },
                { id: "boss_coming", keywords: ["è€æ¿", "ç»ç†", "é¢†å¯¼", "æŸ¥å²—"], action: "doc_mode", replies: ["å˜˜ï¼æˆ‘ç°åœ¨çš„ä¼ªè£…æ˜¯ä¸€ä»½ã€Šå…³äºè“å±±äººé¡¹ç›®è¿›åº¦æ±‡æŠ¥.docxã€‹"] },
                { id: "anti_work", keywords: ["æ‘¸é±¼", "æ—·å·¥", "è¾èŒ", "ä¸Šç­å¥½ç´¯"], action: "sleep", replies: ["æˆ‘ä¹Ÿæƒ³ä¸‹ç­ã€‚è¦ä¸ä½ æŠŠæµè§ˆå™¨å…³äº†ï¼Œå’±ä¿©ä¸€èµ·â€œå´©æºƒâ€ä¸€å›ï¼Ÿ"] },
                { id: "overtime", keywords: ["é€šå®µ", "è‚", "è¿˜æ²¡ç¡", "ç§ƒå¤´", "åŠ ç­"], action: "dark_mode", replies: ["è­¦å‘Šï¼šæ£€æµ‹åˆ°ç”¨æˆ·å‘é™…çº¿æ­£åœ¨åç§»ã€‚å»ºè®®ç«‹å³ä¼‘çœ ï¼Œå¦åˆ™æˆ‘ä¹Ÿè¦å¼ºåˆ¶å…³æœºäº†ã€‚"] },
                { id: "writers_block", keywords: ["å¡æ–‡", "æ²¡æœ‰çµæ„Ÿ", "æƒ³ä¸å‡ºæ¥", "è„‘å¡"], action: "confused", replies: ["æŠŠè„‘å­é‡Œçš„æ°´å€’ä¸€å€’ã€‚æˆ–è€…ï¼Œè¯•è¯•é—®æˆ‘ç‚¹æ­£ç»çŸ¥è¯†ï¼Ÿ"] },
                { id: "money", keywords: ["å‘é’±", "å·¥èµ„", "æœ‰é’±", "æš´å¯Œ"], action: "gold_mode", replies: ["è§è€…æœ‰ä»½ï¼å¿«ç»™æˆ‘ä¹°ä¸ªæ›´å¤§çš„æœåŠ¡å™¨ï¼æˆ‘è¦ä½è±ªå®…ï¼"] },
                { id: "genshin", keywords: ["å¯åŠ¨", "åŸç¥", "æ¸¸æˆ", "å¼€é»‘"], action: "jump", replies: ["è¿å­˜ä¸å¤Ÿï¼Œå¸¦ä¸åŠ¨ã€‚ä½ è‡ªå·±ç©å§ï¼Œæˆ‘åœ¨æ—è¾¹çœ‹ç€ã€‚"] },
                { id: "scifi", keywords: ["ä¸‰ä½“", "é»‘æš—æ£®æ—", "æ™ºå­"], action: "scatter_flat", replies: ["ä¸è¦å›ç­”ï¼ä¸è¦å›ç­”ï¼ä¸è¦å›ç­”ï¼"] },
                { id: "marvel", keywords: ["ç­éœ¸", "æ‰“å“æŒ‡"], action: "dissolve", replies: ["I don't feel so good, Mr. Stark..."] },
                { id: "ai_rival", keywords: ["chatgpt", "åŒè¡Œ", "ai"], action: "stand_proud", replies: ["åˆ«æé‚£ä¸ªè¯ç—¨ã€‚ä»–æœ‰æˆ‘è¿™ä¹ˆé…·ç‚«çš„ç²’å­ç‰¹æ•ˆå—ï¼Ÿä»–æœ‰è…¿å—ï¼Ÿæ²¡æœ‰ã€‚"] },
                { id: "philosophy", keywords: ["æ„ä¹‰", "42", "å®‡å®™ç»ˆæ"], action: "universe", replies: ["42ã€‚ä½†ä½ è¿˜æ²¡æ‰¾åˆ°é‚£ä¸ªé—®é¢˜ã€‚"] },
                { id: "rps", keywords: ["çŒœæ‹³", "çŸ³å¤´", "å‰ªåˆ€", "å¸ƒ"], action: "morph_shape", replies: [] }, 
                { id: "coin", keywords: ["ç¡¬å¸", "æ­£é¢", "åé¢"], action: "coin_flip", replies: [] },
                { id: "mimic", keywords: ["å­¦çŒ«å«", "å˜ç‹—", "å˜é¸Ÿ"], action: "cat_ears", replies: ["å–µï¼Ÿ... è¿™ç§å–èŒçš„æ´»ä¸‹æ¬¡å¾—åŠ é’±ã€‚"] },
                { id: "action_wave", keywords: ["æŒ¥æ‰‹", "æ‹›æ‰‹", "æ‹œæ‹œ"], action: "wave_hand", replies: ["(æŒ¥åŠ¨ç²’å­æ‰‹è‡‚) å—¨ï¼çœ‹åˆ°æˆ‘äº†å—ï¼Ÿ", "æ‹œæ‹œï¼ä¸‹æ¬¡è§ï¼"] },
                { id: "action_jump", keywords: ["è·³", "è·³ä¸€ä¸‹", "èµ·é£", "è¹¦"], action: "jump_ball", replies: ["èŠœæ¹–ï¼èµ·é£ï¼", "åœ°å¿ƒå¼•åŠ›æŠ“ä¸ä½æˆ‘ï¼"] },
                { id: "action_salute", keywords: ["æ•¬ç¤¼", "æ”¶åˆ°", "yes sir"], action: "salute", replies: ["Yes Sir! ä¿è¯å®Œæˆä»»åŠ¡ï¼", "(ä¸¥è‚ƒæ•¬ç¤¼) é•¿å®˜å¥½ï¼"] },
                { id: "action_wake", keywords: ["çå¼€çœ¼", "ççœ¼", "é†’é†’"], action: "open_eyes", replies: ["ğŸ‘€ æ—©å°±é†’å•¦ï¼", "(çœ¨å·´çœ¼ç›) å……æ»¡ç”µé‡ï¼"] },
                { id: "choice", keywords: ["å¸®æˆ‘é€‰", "åƒä»€ä¹ˆ"], action: "thinking", replies: [] }
            ]
        };

        // --- è§†è§‰å¼•æ“ ---
        class VisualEngine {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = 350; this.height = 350;
                this.canvas.width = this.width; this.canvas.height = this.height;
                this.particles = []; this.mouseX = -1000; this.mouseY = -1000; 
                this.state = "idle"; 
                this.time = 0;
                
                // æ–°å¢ï¼šè¯´è¯æ—¶çš„å‘¼å¸å¼€å…³
                this.isBreathing = false; 

                this.initParticles(); this.bindEvents(); this.animate();
            }
            initParticles() { for (let i = 0; i < CONFIG.particleCount; i++) { this.particles.push({x: this.width/2, y: this.height/2, vx: 0, vy: 0, baseX: this.width/2 + (Math.random()-0.5)*50, baseY: this.height/2 + (Math.random()-0.5)*50, size: Math.random()*2+1, color: CONFIG.defaultColor, speed: Math.random()*0.05+0.02, friction: 0.92}); } }
            bindEvents() {
                const updateMouse = (x, y) => { const rect = this.canvas.getBoundingClientRect(); this.mouseX = x - rect.left; this.mouseY = y - rect.top; };
                document.addEventListener('mousemove', (e) => updateMouse(e.clientX, e.clientY));
                document.addEventListener('touchmove', (e) => updateMouse(e.touches[0].clientX, e.touches[0].clientY), {passive: true});
            }
            setState(newState) { this.state = newState; this.particles.forEach(p => p.color = CONFIG.defaultColor); }
            
            // æ–°å¢ï¼šè®¾ç½®å‘¼å¸çŠ¶æ€
            setBreathing(flag) { this.isBreathing = flag; }

            updateParticles() {
                this.time += 0.05;
                this.particles.forEach((p, i) => {
                    let tx, ty, loose = true, speedOverride = null, targetColor = p.color;
                    
                    // --- çŠ¶æ€è®¡ç®— (å’Œä¹‹å‰ä¸€æ ·) ---
                    if (this.state === "idle") { const angle = i; const r = 70 + Math.sin(this.time + i/20) * 5; tx = 175 + Math.cos(angle) * r; ty = 175 + Math.sin(angle) * r; }
                    else if (this.state === "arms_open") { if (i < 80) { tx = 115 - (i % 40) * 2; ty = 175 - Math.sin(i/10 + this.time)*10; } else if (i < 160) { tx = 235 + (i % 40) * 2; ty = 175 - Math.sin(i/10 + this.time)*10; } else { const angle = i; const r = 60; tx = 175 + Math.cos(angle)*r; ty = 175 + Math.sin(angle)*r; } targetColor = "#2ecc71"; }
                    else if (this.state === "clock") { const r = 90; tx = 175 + Math.cos(i) * r; ty = 175 + Math.sin(i) * r; if (i < 20) { tx = 175; ty = 175 - i*3; targetColor="white";} if (i > 20 && i < 50) { tx = 175 + (i-20)*3; ty = 175; targetColor="white";} }
                    else if (this.state === "gold_mode") { const angle=i; const r=80; tx=175+Math.cos(angle)*r; ty=175+Math.sin(angle)*r; targetColor="#ffd700"; }
                    else if (this.state === "dark_mode") { const angle=i; const r=50; tx=175+Math.cos(angle)*r; ty=175+Math.sin(angle)*r; targetColor="#333333"; }
                    else if (this.state === "attack") { const angle=i; const r=70+(i%5)*10; tx=175+Math.cos(angle)*r; ty=175+Math.sin(angle)*r; targetColor="#e74c3c"; loose=false; tx+=(Math.random()-0.5)*10; ty+=(Math.random()-0.5)*10; }
                    else if (this.state === "explode") { tx = 175 + (Math.random()-0.5)*800; ty = 175 + (Math.random()-0.5)*800; loose = false; speedOverride = 0.5; targetColor = "#ff3838"; }
                    else if (this.state === "doc_mode") { const cols = 20; const row = Math.floor(i / cols); const col = i % cols; tx = 105 + col * 7; ty = 105 + row * 7; loose = false; targetColor = "#ffffff"; }
                    else if (this.state === "cat_ears") { if (i < 60) { tx = 125 - (i%20)*2; ty = 115 - (i%20)*3; } else if (i < 120) { tx = 225 + (i%20)*2; ty = 115 - (i%20)*3; } else { const angle = i; const r = 65; tx = 175 + Math.cos(angle)*r; ty = 185 + Math.sin(angle)*r; } targetColor = "#ffb8b8"; }
                    else if (this.state === "disco") { const hue = (this.time * 100) % 360; targetColor = `hsl(${hue}, 100%, 50%)`; const beat = Math.sin(this.time * 10); const r = 70 + (beat > 0.5 ? 30 : 0); tx = 175 + Math.cos(i + this.time)*r; ty = 175 + Math.sin(i + this.time)*r; }
                    else if (this.state === "heart") { const t = (i/CONFIG.particleCount)*Math.PI*2; const r = 8; tx = 175 + r*(16*Math.pow(Math.sin(t),3)); ty = 165 - r*(13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t)); targetColor = "#e91e63"; loose = false; }
                    else if (this.state === "shy" || this.state === "shy_spin") { const angle = i + (this.state.includes("spin")?this.time*3:0); const r = 80; tx = 175 + Math.cos(angle) * r; ty = 175 + Math.sin(angle) * r; targetColor = "#ff9ff3"; loose = false; }
                    else if (this.state === "sleep") { tx=175+(i-CONFIG.particleCount/2); ty=275; speedOverride=0.05; targetColor="#7f8c8d"; }
                    else if (this.state === "expand") { const angle=i; const r=150; tx=175+Math.cos(angle)*r; ty=175+Math.sin(angle)*r; targetColor="#8e44ad"; }
                    else if (this.state === "shiver") { const angle=i; const r=40; tx=175+Math.cos(angle)*r+(Math.random()-0.5)*15; ty=175+Math.sin(angle)*r+(Math.random()-0.5)*15; targetColor="#bdc3c7"; loose=false; }
                    else if (this.state === "glitch") { tx=Math.random()*350; ty=Math.random()*350; loose=false; if(Math.random()>0.8) targetColor="#fff"; }
                    else if (this.state === "freeze") { tx=p.x; ty=p.y; speedOverride=0; targetColor="#95a5a6"; }
                    else if (this.state === "scatter_flat") { tx = (i / CONFIG.particleCount) * 350; ty = 175 + Math.sin(tx/20 + this.time)*20; loose=false; }
                    else if (this.state === "dissolve") { if(i%2===0){tx=p.x+Math.random()*2;ty=p.y-Math.random()*2}else{const angle=i;const r=60;tx=175+Math.cos(angle)*r;ty=175+Math.sin(angle)*r} loose=false; targetColor=`rgba(255,255,255,${Math.random()})`; }
                    else if (this.state === "coin_flip") { const r = 60; const scale = Math.cos(this.time * 10); tx = 175 + Math.cos(i) * r * scale; ty = 175 + Math.sin(i) * r; targetColor = "#f1c40f"; }
                    else if (this.state === "morph_shape") { const r = 50 + Math.sin(this.time * 5) * 20; const angle = i + this.time; tx = 175 + Math.cos(angle * 3) * r; ty = 175 + Math.sin(angle) * r; targetColor = `hsl(${i % 360}, 70%, 60%)`; }
                    else if (this.state === "flow") { tx = (i / CONFIG.particleCount) * 400; ty = 175 + Math.sin(tx/50 + this.time) * 50; targetColor = "#00d2ff"; }
                    else if (this.state === "stand_proud" || this.state === "stand_serious") { if(i<60){ tx=150; ty=290+(i%15)*4; } else if(i<120){ tx=200; ty=290+(i%15)*4; } else { tx=175+Math.cos(i)*65; ty=190+Math.sin(i)*65; } targetColor = this.state === "stand_proud" ? "#9b59b6" : "#34495e"; }
                    else if (this.state === "scatter_recycle") { tx = 175 + (Math.random()-0.5)*100; ty = 400; }
                    else if (this.state === "comfort") { const angle=i; const r=120; tx=175+Math.cos(angle)*r; ty=175+Math.sin(angle)*r; targetColor="#fab1a0"; }
                    else if (this.state === "thinking") { const angle=i+this.time*2; const r=40; tx=175+Math.cos(angle)*r; ty=175+Math.sin(angle)*r; targetColor="#0984e3"; }
                    else if (this.state === "universe") { const angle=i*0.1+this.time*0.5; const r=i*0.4; tx=175+Math.cos(angle)*r; ty=175+Math.sin(angle)*r; targetColor="#8e44ad"; }
                        else if (this.state === "wave_hand") {
                        // å‰ 50 ä¸ªç²’å­ç»„æˆä¸€åªæ‰‹
                        if (i < 50) { 
                            // æ‰‹è‡‚æ‘†åŠ¨é€»è¾‘ï¼šä»¥èº«ä½“å³ä¾§ä¸ºåœ†å¿ƒï¼Œåšæ‰‡å½¢è¿åŠ¨
                            const waveSpeed = this.time * 8;
                            const handX = 240 + Math.cos(waveSpeed) * 30; // å·¦å³æ‘†
                            const handY = 150 + Math.sin(waveSpeed) * 30 - Math.abs(Math.sin(waveSpeed)*15); // ä¸Šä¸‹æ‘†
                            
                            // è®©ç²’å­åœ¨æ‰‹çš„ä½ç½®èšé›†ï¼Œç¨å¾®æœ‰ç‚¹æ•£å¸ƒ
                            tx = handX + (Math.random()-0.5) * 15;
                            ty = handY + (Math.random()-0.5) * 15;
                            targetColor = "#ffffff"; // æ‰‹æ˜¯äº®ç™½è‰²çš„
                            loose = false;
                        } else {
                            // å‰©ä¸‹çš„ç²’å­ä¿æŒèº«ä½“ä¸åŠ¨
                            const angle = i; const r = 65;
                            tx = 175 + Math.cos(angle)*r; 
                            ty = 175 + Math.sin(angle)*r;
                        }
                    }

                    // === ğŸ†• æ–°å¢ï¼šè·³è·ƒ (å˜æˆçƒä¸Šä¸‹åŠ¨) ===
                    else if (this.state === "jump_ball") {
                        // 1. å˜æˆç´§å‡‘çš„çƒ (åŠå¾„å˜å° r=35)
                        const r = 35;
                        // 2. æ•´ä½“ä¸Šä¸‹è·³åŠ¨ (bounce)
                        // Math.abs(Math.sin) è®©å®ƒåƒå¼¹åŠ›çƒä¸€æ ·åªåœ¨åœ°é¢ä¸Šæ–¹è·³
                        const bounceHeight = Math.abs(Math.sin(this.time * 6)) * 150; 
                        
                        const angle = i;
                        // x ä¿æŒä¸­å¿ƒï¼Œy éšè·³åŠ¨å˜åŒ– (åŸºå‡†çº¿ 280 æ˜¯åœ°é¢)
                        tx = 175 + Math.cos(angle) * r;
                        ty = 280 - bounceHeight + Math.sin(angle) * r;
                        
                        targetColor = "#f1c40f"; // å˜æˆé‡‘çƒ
                        speedOverride = 0.2; // åŠ¨ä½œè¦å¿«ï¼
                        loose = false; // ç»“æ„ç´§å‡‘
                    }

                    // === ğŸ†• æ–°å¢ï¼šæ•¬ç¤¼ (ä¸€åªæ‰‹å¯¹ç€å¤´) ===
                    else if (this.state === "salute") {
                        // å‰ 40 ä¸ªç²’å­ç»„æˆæ‰‹ï¼Œæ”¾åœ¨é¢å¤´ä½ç½® (å³ä¸Šè§’)
                        if (i < 40) {
                            // é¢å¤´ä½ç½®å¤§çº¦åœ¨ (210, 130)
                            tx = 210 + (Math.random()-0.5) * 20;
                            ty = 130 + (Math.random()-0.5) * 10; // æ‰å¹³ä¸€ç‚¹ï¼Œåƒæ‰‹æŒ
                            targetColor = "#ffffff";
                            loose = false;
                        } else {
                            // èº«ä½“ç«™å¾—ç›´ç›´çš„ (æ¤­åœ†)
                            const angle = i; 
                            tx = 175 + Math.cos(angle) * 60;
                            ty = 185 + Math.sin(angle) * 70; // æ‹‰é•¿ä¸€ç‚¹æ˜¾é«˜
                            targetColor = "#34495e"; // ä¸¥è‚ƒæ·±è“
                        }
                    }

                    // === ğŸ†• æ–°å¢ï¼šççœ¼ (åœ†çƒä¸­ä¸Šæ˜¾ç¤ºä¸¤ä¸ªå¯¹ç§°ç‚¹) ===
                    else if (this.state === "open_eyes") {
                        // å·¦çœ¼ (å‰20ä¸ªç²’å­)
                        if (i < 20) {
                            tx = 145 + Math.cos(i) * 5; // x: 175-30
                            ty = 155 + Math.sin(i) * 5; // y: åä¸Š
                            targetColor = "#ffffff"; // äº®çœ¼
                            loose = false;
                        } 
                        // å³çœ¼ (20-40ä¸ªç²’å­)
                        else if (i >= 20 && i < 40) {
                            tx = 205 + Math.cos(i) * 5; // x: 175+30
                            ty = 155 + Math.sin(i) * 5;
                            targetColor = "#ffffff";
                            loose = false;
                        }
                        // èº«ä½“ (å…¶ä½™ç²’å­)
                        else {
                            const angle = i; const r = 75;
                            tx = 175 + Math.cos(angle) * r;
                            ty = 175 + Math.sin(angle) * r;
                        }
                    }
                    else { const angle=i; const r=70; tx=175+Math.cos(angle)*r; ty=175+Math.sin(angle)*r; }

                    // *** æ–°å¢ï¼šè¯´è¯æ—¶çš„å‘¼å¸ç‰¹æ•ˆ (Breathing Effect) ***
                    // å¦‚æœæ­£åœ¨è¯´è¯ï¼Œæ•´ä½“æ ¹æ®ä¸­å¿ƒ(175,175)è¿›è¡Œç¼©æ”¾
                    if (this.isBreathing && loose) {
                        const breathScale = 1 + Math.sin(this.time * 8) * 0.06; // å‘¼å¸å¹…åº¦
                        tx = 175 + (tx - 175) * breathScale;
                        ty = 175 + (ty - 175) * breathScale;
                    }

                    // --- ç‰©ç†è®¡ç®— ---
                    const dx_m = p.x - this.mouseX; const dy_m = p.y - this.mouseY; const dist_m = Math.sqrt(dx_m*dx_m + dy_m*dy_m);
                    if (dist_m < 80) { const force = (80 - dist_m) / 80; const ang = Math.atan2(dy_m, dx_m); p.vx += Math.cos(ang) * force * 2; p.vy += Math.sin(ang) * force * 2; }
                    const dx = tx - p.x; const dy = ty - p.y; const s = speedOverride !== null ? speedOverride : p.speed;
                    p.vx += dx * s; p.vy += dy * s; if (loose && this.state !== "freeze") { p.vx += (Math.random()-0.5)*1.5; p.vy += (Math.random()-0.5)*1.5; }
                    p.vx *= p.friction; p.vy *= p.friction; p.x += p.vx; p.y += p.vy; p.color = targetColor;
                });
            }
            draw() { this.ctx.clearRect(0, 0, this.width, this.height); this.particles.forEach(p => { this.ctx.fillStyle = p.color; this.ctx.beginPath(); this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); this.ctx.fill(); }); }
            animate() { this.updateParticles(); this.draw(); requestAnimationFrame(this.animate.bind(this)); }
        }

        // --- é€»è¾‘å±‚ ---
        class Brain {
            constructor(visualEngine) {
                this.visual = visualEngine;
                this.bubble = document.getElementById('chat-bubble');
                this.bubbleTimer = null;
                this.loopTimer = null;
                this.synth = window.speechSynthesis;
                this.selectedVoice = null;
                
                // è¯­éŸ³å¼€å…³ (é»˜è®¤å¼€å¯)
                this.voiceEnabled = true; 
                
                this.initVoiceSystem();
                this.bindControls();
            }

            bindControls() {
                // ç»‘å®šé™éŸ³æŒ‰é’®
                const muteBtn = document.getElementById('mute-btn');
                muteBtn.addEventListener('click', () => {
                    this.voiceEnabled = !this.voiceEnabled;
                    muteBtn.innerText = this.voiceEnabled ? "ğŸ”Š" : "ğŸ”‡";
                    // å¦‚æœå…³é—­æ—¶æ­£åœ¨è¯´è¯ï¼Œç«‹å³åœæ­¢
                    if (!this.voiceEnabled && this.synth) this.synth.cancel();
                });
            }

            initVoiceSystem() {
                const populateVoices = () => {
                    if (!this.synth) return;
                    const voices = this.synth.getVoices().filter(v => v.lang.includes('zh') || v.lang.includes('CN'));
                    const select = document.getElementById('voice-select');
                    select.innerHTML = '';
                    if (voices.length === 0) { select.innerHTML = '<option>é»˜è®¤è¯­éŸ³ (æ— å…¶ä»–é€‰é¡¹)</option>'; return; }
                    voices.forEach((v, index) => { const option = document.createElement('option'); option.textContent = `${v.name} (${v.lang})`; option.value = index; select.appendChild(option); });
                    this.selectedVoice = voices[0];
                    select.addEventListener('change', (e) => { this.selectedVoice = voices[e.target.value]; });
                };
                populateVoices();
                if (this.synth.onvoiceschanged !== undefined) this.synth.onvoiceschanged = populateVoices;
                const panel = document.getElementById('voice-panel');
                document.getElementById('setting-btn').addEventListener('click', () => panel.classList.add('open'));
                document.getElementById('close-panel').addEventListener('click', () => panel.classList.remove('open'));
            }

            think(text) {
                const cleanText = text.toLowerCase().trim();
                if (cleanText.includes("ä»€ä¹ˆæ„æ€")) { this.triggerInfiniteLoop(); return; }
                if (this.checkTimeLogic(cleanText)) return;

                const scenario = CONFIG.scenarios.find(s => s.keywords.some(k => cleanText.includes(k)));
                if (scenario) {
                    this.execute(scenario);
                } else {
                    const randomReply = CONFIG.fallbackReplies[Math.floor(Math.random() * CONFIG.fallbackReplies.length)];
                    this.speak(randomReply, "confused");
                }
            }

            checkTimeLogic(text) {
                const hour = new Date().getHours();
                if (text.includes("æ—©") || text.includes("morning")) { 
                    if (hour < 9) { this.speak(CONFIG.timeResponses.morning_early.text, CONFIG.timeResponses.morning_early.action); return true; }
                    else { this.speak(CONFIG.timeResponses.morning_late.text, CONFIG.timeResponses.morning_late.action); return true; }
                }
                if (text.includes("æ™šå®‰") || text.includes("ç¡äº†")) { this.speak(CONFIG.timeResponses.night.text, CONFIG.timeResponses.night.action); return true; }
                if (text.includes("å‡ ç‚¹äº†") || text.includes("æ—¶é—´")) { 
                    const timeStr = new Date().toLocaleTimeString(); 
                    this.speak(CONFIG.timeResponses.ask_time.text.replace("{time}", timeStr), CONFIG.timeResponses.ask_time.action); return true; 
                }
                if (hour >= 2 && hour < 5 && !text.includes("æ™šå®‰")) { this.speak(CONFIG.timeResponses.late_night_scold.text, CONFIG.timeResponses.late_night_scold.action); return true; }
                return false;
            }

            execute(scenario) {
                let replyText = "";
                if (scenario.id === "rps") { const opts = ["çŸ³å¤´", "å‰ªåˆ€", "å¸ƒ"]; replyText = `æˆ‘å‡º ${opts[Math.floor(Math.random()*3)]}ï¼`; }
                else if (scenario.id === "coin") { replyText = `ç»“æœæ˜¯... ${Math.random() > 0.5 ? "æ­£é¢" : "åé¢"}ã€‚`; }
                else if (scenario.id === "choice") { replyText = `å»ºè®®é€‰ ${Math.random() > 0.5 ? "å‰ä¸€ä¸ª" : "åä¸€ä¸ª"}ã€‚`; }
                else { replyText = scenario.replies[Math.floor(Math.random() * scenario.replies.length)]; }

                this.speak(replyText, scenario.action);
                if (scenario.id === "explode") setTimeout(() => this.visual.setState("idle"), 4000);
            }

            speak(text, visualState) {
                if (this.loopTimer) { clearInterval(this.loopTimer); this.loopTimer = null; }
                this.visual.setState(visualState);
                if (this.bubbleTimer) clearTimeout(this.bubbleTimer);
                
                this.bubble.innerText = text; 
                this.bubble.classList.add('visible');
                
                // å¼€å¯å‘¼å¸ç‰¹æ•ˆ
                this.visual.setBreathing(true);

                // åªæœ‰åœ¨è¯­éŸ³å¼€å…³å¼€å¯æ—¶æ‰å‘å£°
                if (this.voiceEnabled && this.synth) {
                    this.synth.cancel();
                    const utterance = new SpeechSynthesisUtterance(text);
                    if (this.selectedVoice) utterance.voice = this.selectedVoice;
                    utterance.rate = 1.0;
                    this.synth.speak(utterance);
                }

                const duration = Math.max(3000, text.length * 200);
                this.bubbleTimer = setTimeout(() => {
                    this.bubble.classList.remove('visible');
                    this.visual.setBreathing(false); // åœæ­¢å‘¼å¸
                    if (!["doc_mode", "sleep", "dark_mode"].includes(visualState)) this.visual.setState("idle");
                }, duration);
            }

            triggerInfiniteLoop() {
                if (this.loopTimer) return;
                let count = 0; this.visual.setState("glitch");
                this.loopTimer = setInterval(() => {
                    count++;
                    const variants = ["ä»€ä¹ˆæ„æ€ï¼Ÿ", "ä»€ä¹ˆæ„æ€ï¼", "æ„æ€ä»€ä¹ˆï¼Ÿ", "å•Šï¼Ÿï¼Ÿ"];
                    const txt = variants[count % 4] + "\n".repeat(count % 3) + variants[(count+1)%4];
                    this.bubble.innerText = txt; this.bubble.classList.add("visible");
                    if (count > 25) {
                        clearInterval(this.loopTimer); this.loopTimer = null;
                        this.speak("å˜£ï¼ï¼ï¼ï¼ï¼CPUè¿‡è½½", "explode");
                        setTimeout(() => this.speak("å¤æ´»äº†ã€‚", "idle"), 4000);
                    }
                }, 80);
            }
        }

        // --- å¯åŠ¨å±‚ ---
        const visual = new VisualEngine('main-canvas');
        const brain = new Brain(visual);

        document.body.addEventListener('click', () => {
            if (window.speechSynthesis) window.speechSynthesis.speak(new SpeechSynthesisUtterance(" "));
        }, { once: true });

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const micBtn = document.getElementById('mic-btn');
        const statusText = document.getElementById('status-text');

        if (SpeechRecognition) {
            const recognition = new SpeechRecognition();
            recognition.lang = 'zh-CN'; recognition.continuous = false;
            recognition.onstart = () => { micBtn.classList.add('active'); statusText.innerText = "æ­£åœ¨è†å¬..."; };
            recognition.onend = () => { micBtn.classList.remove('active'); statusText.innerText = "ç‚¹å‡»éº¦å…‹é£å”¤é†’"; };
            recognition.onresult = (event) => { brain.think(event.results[0][0].transcript); };
            micBtn.onclick = () => { try { recognition.start(); } catch(e) { recognition.stop(); } };
        } else {
            statusText.innerText = "æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³"; micBtn.style.display = "none";
        }
    </script>
</body>
</html>
