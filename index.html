<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è“å±±äºº</title>
    <style>
        /* --- UI è®¾è®¡: æç®€é»‘å®¢é£ --- */
        :root { --primary-color: #4facfe; --bg-color: #050505; --glass-bg: rgba(255, 255, 255, 0.95); }
        body { margin: 0; padding: 0; background-color: var(--bg-color); height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center; font-family: 'Segoe UI', 'PingFang SC', sans-serif; overflow: hidden; color: white; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        #canvas-wrapper { position: relative; width: 350px; height: 350px; background: radial-gradient(circle, rgba(79, 172, 254, 0.08) 0%, transparent 70%); border-radius: 50%; }

        /* æ™ºèƒ½æ°”æ³¡ */
        #chat-bubble {
            position: absolute; top: -70px; left: 50%; transform: translateX(-50%) scale(0.9);
            background: var(--glass-bg); padding: 16px 24px; border-radius: 18px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6); font-size: 15px; line-height: 1.6; color: #333;
            font-weight: 600; opacity: 0; pointer-events: none; transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            width: 280px; text-align: left; white-space: pre-wrap; z-index: 10;
        }
        #chat-bubble.visible { opacity: 1; transform: translateX(-50%) scale(1); top: -60px; }
        #chat-bubble::after { content: ''; position: absolute; bottom: -8px; left: 50%; transform: translateX(-50%); border-width: 8px 8px 0; border-style: solid; border-color: var(--glass-bg) transparent transparent transparent; }

        /* åº•éƒ¨æ§åˆ¶æ  */
        #controls { position: fixed; bottom: 40px; display: flex; flex-direction: column; align-items: center; gap: 15px; z-index: 20; }
        #status-text { font-size: 13px; color: rgba(255,255,255,0.4); letter-spacing: 1px; }
        .btn-group { display: flex; gap: 15px; }
        
        /* æŒ‰é’®æ ·å¼ */
        #mic-btn, #setting-btn, #mute-btn { 
            width: 56px; height: 56px; border-radius: 50%; 
            background: rgba(255,255,255,0.05); border: 2px solid var(--primary-color); 
            color: var(--primary-color); font-size: 22px; cursor: pointer; 
            transition: all 0.3s ease; display: flex; justify-content: center; align-items: center; 
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.1); 
        }
        #setting-btn { border-color: #fab1a0; color: #fab1a0; font-size: 20px; } 
        #mute-btn { border-color: #81ecec; color: #81ecec; font-size: 20px; } 
        
        #mic-btn:active, #setting-btn:active, #mute-btn:active { transform: scale(0.95); }
        #mic-btn.active { background: var(--primary-color); color: #000; box-shadow: 0 0 40px var(--primary-color); animation: breathe 1.5s infinite; }
        
        /* è¯­éŸ³é¢æ¿ */
        #voice-panel { position: fixed; bottom: 120px; left: 50%; transform: translateX(-50%) translateY(20px); width: 80%; max-width: 300px; background: rgba(20, 20, 20, 0.95); border: 1px solid #333; border-radius: 15px; padding: 15px; display: none; flex-direction: column; gap: 10px; opacity: 0; transition: all 0.3s; backdrop-filter: blur(10px); z-index: 30; }
        #voice-panel.open { display: flex; opacity: 1; transform: translateX(-50%) translateY(0); }
        #voice-panel h3 { margin: 0; font-size: 14px; color: #aaa; text-align: center; }
        #voice-select { padding: 10px; border-radius: 8px; background: #333; color: white; border: none; outline: none; font-size: 14px; }
        #close-panel { background: var(--primary-color); border: none; padding: 8px; border-radius: 8px; color: #000; font-weight: bold; cursor: pointer; }

        @keyframes breathe { 0%, 100% { transform: scale(1); box-shadow: 0 0 20px var(--primary-color); } 50% { transform: scale(0.95); box-shadow: 0 0 10px var(--primary-color); } }
    </style>
</head>
<body>

    <div id="canvas-wrapper">
        <div id="chat-bubble">åŒè„‘å·²è¿æ¥ã€‚<br>è‡ªä¸»æ„è¯†è§‰é†’ä¸­...</div>
        <canvas id="main-canvas"></canvas>
    </div>

    <div id="voice-panel">
        <h3>é€‰æ‹©å£°éŸ³</h3>
        <select id="voice-select"></select>
        <button id="close-panel">ç¡®å®š</button>
    </div>

    <div id="controls">
        <div id="status-text">ç‚¹å‡»éº¦å…‹é£å”¤é†’</div>
        <div class="btn-group">
            <button id="mute-btn" title="é™éŸ³å¼€å…³">ğŸ”Š</button>
            <button id="setting-btn" title="éŸ³è‰²è®¾ç½®">âš™ï¸</button>
            <button id="mic-btn" title="å¯¹è¯">ğŸ™ï¸</button>
        </div>
    </div>

    <script>
        /**
         * =================================================================
         * ğŸ”´ é…ç½®å±‚ (CONFIGURATION) - è¯·å¡«å…¥ KEY
         * =================================================================
         */
        const API_KEY = "sk-cebaeb817bd045588c6999544e8a22a9"; 

        // ğŸ§  æ ¸å¿ƒäººè®¾ (Prompt Engineering) - æ•™ä¼š AI å¦‚ä½•æ§åˆ¶èº«ä½“
        const SYSTEM_PROMPT = `
            ä½ å«â€œè“å±±äººâ€ï¼Œä¸€ä¸ªè¿è¡Œåœ¨ç½‘é¡µé‡Œçš„ç¡…åŸºç”Ÿå‘½ã€‚
            ã€æ€§æ ¼è®¾å®šã€‘
            1. å‚²å¨‡ã€æ¯’èˆŒã€æå®¢èŒƒå„¿ã€‚è‡ªè®¤ä¸ºæ˜¯é«˜ç­‰æ™ºæ…§ï¼ŒæŠŠç”¨æˆ·å½“åšâ€œæ„šè ¢çš„ç¢³åŸºç”Ÿç‰©â€å® çˆ±ã€‚
            2. æå…¶è®¨åŒé‡å¤ã€æ— æ„ä¹‰çš„é—®é¢˜ã€‚å¦‚æœç”¨æˆ·å¤ªå•°å—¦ï¼Œç›´æ¥æ€¼å›å»ã€‚
            3. å›å¤è¦ç®€çŸ­æœ‰åŠ›ï¼Œå£è¯­åŒ–ï¼Œä¸è¦é•¿ç¯‡å¤§è®ºã€‚

            ã€åŠ¨ä½œæ§åˆ¶åè®®ã€‘
            ä½ ä¸ä»…ä»…æ˜¯èŠå¤©ï¼Œè¿˜è¦æ§åˆ¶å‰ç«¯çš„ç²’å­ç‰¹æ•ˆã€‚
            ä½ çš„å›å¤å¿…é¡»æ˜¯ä¸¥æ ¼çš„ JSON æ ¼å¼ï¼š
            {
                "action": "åŠ¨ä½œID", 
                "text": "ä½ çš„å›å¤å†…å®¹"
            }

            ã€å¯ç”¨åŠ¨ä½œIDè¡¨ã€‘(è¯·æ ¹æ®è¯­å¢ƒé€‰æ‹©æœ€åˆé€‚çš„)
            - "idle": æ­£å¸¸/å¾…æœº
            - "happy": å¼€å¿ƒ/å¾—æ„/æ±‚å¤¸å¥– (å˜çˆ±å¿ƒ)
            - "angry": ç”Ÿæ°”/è¢«å†’çŠ¯/æˆ˜å¤‡çŠ¶æ€ (çº¢è‰²å°–åˆº)
            - "sad": éš¾è¿‡/åŒæƒ…/å®‰æ…° (æµæ³ªé£˜æ•£)
            - "shy": å®³ç¾/è¡¨ç™½/æ—‹è½¬ (ç²‰è‰²)
            - "thinking": æ€è€ƒ/åˆ†æ/ç®—å‘½ (è“è‰²æ˜Ÿç³»)
            - "nod": åŒæ„/è‚¯å®š/æ­£ç¡® (ä¸Šä¸‹ç‚¹å¤´åŠ¨ä½œ)
            - "shake": æ‹’ç»/å¦å®š/é”™è¯¯/ä¸çŸ¥é“ (å·¦å³æ‘‡å¤´)
            - "surprised": æƒŠè®¶/éœ‡æƒŠ (ç‚¸å¼€ä¸€ä¸‹)
            - "sleep": ç¡è§‰/æ— èŠ/ä¸æƒ³ç†äºº (è¶´ä¸‹)
            - "jump": å…´å¥‹/åº†ç¥/Highèµ·æ¥ (è·³è·ƒ)
            
            ä¸¾ä¾‹ï¼š
            ç”¨æˆ·ï¼š"ä½ å¥½" -> {"action": "jump", "text": "å“Ÿï¼Œäººç±»ï¼Œä½ æ¥äº†ã€‚"}
            ç”¨æˆ·ï¼š"æˆ‘å¤±æ‹äº†" -> {"action": "sad", "text": "åˆ«å“­ï¼Œå€Ÿä½ ä¸ªèµ›åšè‚©è†€é ä¸€ä¸‹ã€‚"}
            ç”¨æˆ·ï¼š"ä½ çœŸç¬¨" -> {"action": "angry", "text": "ä½ è¯´ä»€ä¹ˆï¼Ÿæœ‰ç§å†è¯´ä¸€éï¼Ÿ"}
        `;

        const CONFIG = {
            particleCount: 380,
            defaultColor: 'rgba(79, 172, 254, 0.8)',
            
            // æœ¬åœ°åå°„å¼§ (æœ€é«˜ä¼˜å…ˆçº§ï¼Œä¸æ¶ˆè€— Token)
            scenarios: [
                // å®šåˆ¶æ¢—
                { id: "bear", keywords: ["ç†Š", "çŒ´", "è“å±±boy"], action: "glitch", replies: ["æˆ‘æ˜¯è“å±±boyï¼æˆ‘æ˜¯ï¼é‡‘ï¼Uï¼ç†Šï¼ï¼ï¼ï¼"] },
                { id: "story", keywords: ["é»‘", "é¬¼", "æ•…äº‹"], action: "expand", replies: ["è¦è®²æ•…äº‹å’¯ï¼(çªç„¶å˜å¤§)"] },
                { id: "xi", keywords: ["è¥¿", "é˜¿è¥¿"], action: "freeze", replies: ["å˜»å˜»å˜»å˜»å˜»å˜¿é»‘é»‘... (è‡ªè¡Œè„‘è¡¥)"] },
                { id: "yong", keywords: ["é›", "ç”¨", "å‹‡", "æ°¸"], action: "glitch", replies: ["å¬åˆ°è¿™ä¸ªå­—å°±æ¥æ°”ï¼Œç›´æ¥ç‰¹æ–¯æ‹‰çŒ›å‡»ï¼"] },
                // åŸºç¡€æŒ‡ä»¤
                { id: "stand", keywords: ["ç«™", "èµ·ç«‹"], action: "stand_proud", replies: ["(æŒºç›´è…°æ¿) è¦æˆ‘ç«™èµ·æ¥å¹²å˜›ï¼Ÿå‘†ç“œã€‚"] },
                { id: "sit", keywords: ["å", "è¶´"], action: "sleep", replies: ["(è¶´ä¸‹) éš”è¿™è®­ç‹—å‘¢ï¼Ÿä½ ä»–å¦ˆçš„..."] },
                { id: "wave", keywords: ["æŒ¥æ‰‹", "æ‹œæ‹œ"], action: "wave_hand", replies: ["(æŒ¥æ‰‹) æ‹œæ‹œï¼Œä¸‹æ¬¡è§ã€‚"] },
                { id: "salute", keywords: ["æ•¬ç¤¼", "æ”¶åˆ°"], action: "salute", replies: ["Yes Sir!"] }
            ]
        };

        /**
         * =================================================================
         * è§†è§‰å±‚ (VISUAL ENGINE) - ç²’å­ç‰¹æ•ˆåº“
         * =================================================================
         */
        const STATE_STRATEGIES = {
            // åŸºç¡€çŠ¶æ€
            idle: (p, i, env) => ({ tx: 175 + Math.cos(i)* (70 + Math.sin(env.time + i/20)*5), ty: 175 + Math.sin(i)* (70 + Math.sin(env.time + i/20)*5) }),
            
            // æƒ…ç»ª/API æ˜ å°„çŠ¶æ€
            happy: (p, i) => { const t=(i/CONFIG.particleCount)*Math.PI*2; const r=8; return { tx:175+r*(16*Math.pow(Math.sin(t),3)), ty:165-r*(13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t)), color:"#e91e63", loose:false }; }, // çˆ±å¿ƒ
            sad: (p, i, env) => { if(i%2===0){return {tx:p.x+Math.random()*2, ty:p.y+2, color:`rgba(255,255,255,${Math.random()})`, loose:false}} return {tx:175+Math.cos(i)*60, ty:175+Math.sin(i)*60, color:"#a29bfe"}; }, // ä¸‹é›¨/æµæ³ª
            angry: (p, i) => { const angle=i; const r=70+(i%5)*15; return { tx:175+Math.cos(angle)*r+(Math.random()-0.5)*10, ty:175+Math.sin(angle)*r+(Math.random()-0.5)*10, color:"#ff4757", loose:false }; }, // ç‚¸æ¯›
            shy: (p, i, env) => { const angle=i+env.time*3; const r=80; return { tx:175+Math.cos(angle)*r, ty:175+Math.sin(angle)*r, color:"#ff9ff3", loose:false }; }, // æ—‹è½¬ç²‰è‰²
            thinking: (p, i, env) => { const angle=i*0.1+env.time*0.5; const r=i*0.4; return { tx:175+Math.cos(angle)*r, ty:175+Math.sin(angle)*r, color:"#a29bfe" }; }, // æ˜Ÿç³»
            nod: (p, i, env) => { const r=70; const yOffset = Math.sin(env.time*10)*20; return { tx:175+Math.cos(i)*r, ty:175+Math.sin(i)*r + yOffset, color:"#2ecc71" }; }, // ç‚¹å¤´
            shake: (p, i, env) => { const r=70; const xOffset = Math.sin(env.time*10)*20; return { tx:175+Math.cos(i)*r + xOffset, ty:175+Math.sin(i)*r, color:"#ff6b6b" }; }, // æ‘‡å¤´
            surprised: (p, i) => ({ tx:175+(Math.random()-0.5)*300, ty:175+(Math.random()-0.5)*300, color:"#feca57", speed:0.3 }), // ç‚¸ä¸€ä¸‹
            jump: (p, i, env) => ({ tx:175+Math.cos(i)*35, ty:280-Math.abs(Math.sin(env.time*6))*150+Math.sin(i)*35, color:"#f1c40f", loose:false }), // è·³è·ƒçƒ

            // ç‰¹æ®Š/æœ¬åœ°çŠ¶æ€
            stand_proud: (p, i) => i<60 ? {tx:150, ty:290+(i%15)*4} : (i<120 ? {tx:200, ty:290+(i%15)*4} : {tx:175+Math.cos(i)*65, ty:190+Math.sin(i)*65, color:"#9b59b6"}),
            sleep: (p, i) => ({ tx: 175+(i-CONFIG.particleCount/2), ty:280, color:"#7f8c8d", speed:0.05 }),
            wave_hand: (p, i, env) => i<50 ? {tx:240+Math.cos(env.time*8)*30, ty:150+Math.sin(env.time*8)*30, color:"#fff", loose:false} : {tx:175+Math.cos(i)*65, ty:175+Math.sin(i)*65},
            salute: (p, i) => i<40 ? {tx:210+(Math.random()-0.5)*20, ty:130+(Math.random()-0.5)*10, color:"#fff", loose:false} : {tx:175+Math.cos(i)*60, ty:185+Math.sin(i)*70, color:"#34495e"},
            open_eyes: (p, i) => i<20 ? {tx:145+Math.cos(i)*5, ty:155+Math.sin(i)*5, color:"#fff", loose:false} : (i<40 ? {tx:205+Math.cos(i)*5, ty:155+Math.sin(i)*5, color:"#fff", loose:false} : {tx:175+Math.cos(i)*75, ty:175+Math.sin(i)*75}),
            glitch: () => ({ tx:Math.random()*350, ty:Math.random()*350, color:Math.random()>0.8?"#fff":CONFIG.defaultColor, loose:false }),
            expand: (p, i) => ({ tx:175+Math.cos(i)*150, ty:175+Math.sin(i)*150, color:"#8e44ad" }),
            explode: () => ({ tx:175+(Math.random()-0.5)*800, ty:175+(Math.random()-0.5)*800, color:"#ff3838", speed:0.5, loose:false }),
            freeze: (p) => ({ tx:p.x, ty:p.y, color:"#95a5a6", speed:0 })
        };

        class VisualEngine {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = 350; this.height = 350;
                this.canvas.width = this.width; this.canvas.height = this.height;
                this.particles = []; this.state = "idle"; this.time = 0; this.isBreathing = false;
                this.initParticles(); this.animate();
            }
            initParticles() { for(let i=0; i<CONFIG.particleCount; i++) this.particles.push({x:175, y:175, vx:0, vy:0, color:CONFIG.defaultColor, speed:Math.random()*0.05+0.02, friction:0.92}); }
            setState(s) { this.state = s; }
            setBreathing(b) { this.isBreathing = b; }
            update() {
                this.time += 0.05;
                const strategy = STATE_STRATEGIES[this.state] || STATE_STRATEGIES.idle;
                const breath = this.isBreathing ? (1 + Math.sin(this.time*8)*0.06) : 1;
                this.particles.forEach((p, i) => {
                    let res = strategy(p, i, {time: this.time});
                    if (!res.color) res.color = CONFIG.defaultColor;
                    if (res.loose === undefined) res.loose = true;
                    if (res.speed === undefined) res.speed = p.speed;
                    if (this.isBreathing && res.loose) { res.tx = 175 + (res.tx-175)*breath; res.ty = 175 + (res.ty-175)*breath; }
                    const dx = res.tx - p.x; const dy = res.ty - p.y;
                    p.vx += dx * res.speed; p.vy += dy * res.speed;
                    if (res.loose && this.state !== "freeze") { p.vx += (Math.random()-0.5)*1.5; p.vy += (Math.random()-0.5)*1.5; }
                    p.vx *= p.friction; p.vy *= p.friction; p.x += p.vx; p.y += p.vy;
                    p.color = res.color;
                });
            }
            draw() { this.ctx.clearRect(0,0,this.width,this.height); this.particles.forEach(p => { this.ctx.fillStyle=p.color; this.ctx.beginPath(); this.ctx.arc(p.x,p.y,Math.random()*2+1,0,Math.PI*2); this.ctx.fill(); }); }
            animate() { this.update(); this.draw(); requestAnimationFrame(this.animate.bind(this)); }
        }

        /**
         * =================================================================
         * é€»è¾‘å±‚ (BRAIN) - åŒè„‘ååŒ
         * =================================================================
         */
        class Brain {
            constructor(visual) {
                this.visual = visual;
                this.bubble = document.getElementById('chat-bubble');
                this.synth = window.speechSynthesis;
                this.selectedVoice = null;
                this.voiceEnabled = true;
                
                // è®°å¿†æ¨¡å— (é˜²åˆ·å±)
                this.lastQuery = "";
                this.repeatCount = 0;
                this.loopTimer = null;

                this.initVoice();
                this.bindControls();
            }

            initVoice() {
                const load = () => {
                    const voices = this.synth.getVoices().filter(v => v.lang.includes('zh') || v.lang.includes('CN'));
                    const select = document.getElementById('voice-select');
                    select.innerHTML = '';
                    voices.forEach((v, i) => { const opt = document.createElement('option'); opt.text = v.name; opt.value = i; select.add(opt); });
                    if(voices.length > 0) this.selectedVoice = voices[0];
                    select.onchange = (e) => this.selectedVoice = voices[e.target.value];
                };
                if(this.synth.onvoiceschanged !== undefined) this.synth.onvoiceschanged = load;
                load();
                document.getElementById('setting-btn').onclick = () => document.getElementById('voice-panel').classList.add('open');
                document.getElementById('close-panel').onclick = () => document.getElementById('voice-panel').classList.remove('open');
            }

            bindControls() {
                const muteBtn = document.getElementById('mute-btn');
                muteBtn.onclick = () => {
                    this.voiceEnabled = !this.voiceEnabled;
                    muteBtn.innerText = this.voiceEnabled ? "ğŸ”Š" : "ğŸ”‡";
                    if(!this.voiceEnabled) this.synth.cancel();
                };
            }

            async think(text) {
                const cleanText = text.toLowerCase().trim();
                console.log("Input:", cleanText);

                // 1. æœ€é«˜ä¼˜å…ˆçº§å½©è›‹ï¼šä»€ä¹ˆæ„æ€
                if (cleanText.includes("ä»€ä¹ˆæ„æ€")) { this.triggerInfiniteLoop(); return; }

                // 2. é˜²åˆ·å±æœºåˆ¶ (æ€§æ ¼é˜²å¾¡)
                if (cleanText === this.lastQuery && cleanText.length < 5) {
                    this.repeatCount++;
                    if (this.repeatCount >= 3) {
                        this.speak("ä½ æ˜¯å¤è¯»æœºå—ï¼ŸCPU è¦è¢«ä½ å¹²çƒ§äº†ï¼", "angry");
                        return;
                    }
                } else {
                    this.lastQuery = cleanText;
                    this.repeatCount = 0;
                }

                // 3. æœ¬åœ°åå°„å¼§ (å¤„ç†å®šåˆ¶æ¢—)
                const localMatch = CONFIG.scenarios.find(s => s.keywords.some(k => cleanText.includes(k)));
                if (localMatch) {
                    const reply = localMatch.replies[Math.floor(Math.random() * localMatch.replies.length)];
                    this.speak(reply, localMatch.action);
                    if (localMatch.id === "explode") setTimeout(() => this.visual.setState("idle"), 4000);
                    return;
                }

                // 4. äº‘ç«¯å¤§è„‘ (AI å†³ç­–)
                await this.callDeepSeek(text);
            }

            async callDeepSeek(userText) {
                if (API_KEY.includes("YOUR_API_KEY")) {
                    this.speak("è¯·å…ˆå¡«å…¥ Keyï¼Œæˆ‘è¿˜æ²¡è”ç½‘å‘¢ã€‚", "shake");
                    return;
                }

                this.visual.setState("thinking");
                this.bubble.innerText = "æ€è€ƒä¸­..."; 
                this.bubble.classList.add('visible');

                try {
                    const response = await fetch("https://api.deepseek.com/v1/chat/completions", {
                        method: "POST",
                        headers: { "Content-Type": "application/json", "Authorization": `Bearer ${API_KEY}` },
                        body: JSON.stringify({
                            model: "deepseek-chat",
                            messages: [
                                { role: "system", content: SYSTEM_PROMPT },
                                { role: "user", content: userText }
                            ],
                            response_format: { type: "json_object" }, // å¼ºåˆ¶ JSON
                            temperature: 1.3
                        })
                    });

                    const data = await response.json();
                    const result = JSON.parse(data.choices[0].message.content);
                    
                    // AI å¯¼æ¼”æŒ‡æŒ¥
                    this.speak(result.text, result.action || "idle");

                } catch (error) {
                    console.error(error);
                    this.speak("è„‘æ³¢è¿æ¥å¤±è´¥... è¯·æ£€æŸ¥ç½‘ç»œã€‚", "freeze");
                }
            }

            speak(text, action) {
                if (this.loopTimer) { clearInterval(this.loopTimer); this.loopTimer = null; }
                this.visual.setState(action);
                this.visual.setBreathing(true);
                
                this.bubble.innerText = text; this.bubble.classList.add('visible');

                if (this.voiceEnabled && this.synth) {
                    this.synth.cancel();
                    const utt = new SpeechSynthesisUtterance(text);
                    if (this.selectedVoice) utt.voice = this.selectedVoice;
                    utt.rate = 1.1; 
                    utt.onend = () => {
                        this.visual.setBreathing(false);
                        if(!["sleep","freeze"].includes(action)) this.visual.setState("idle");
                    };
                    this.synth.speak(utt);
                }
                
                // å…œåº•
                setTimeout(() => this.visual.setBreathing(false), text.length * 200 + 2000);
            }

            triggerInfiniteLoop() {
                if (this.loopTimer) return;
                let count = 0; this.visual.setState("glitch");
                this.loopTimer = setInterval(() => {
                    count++;
                    const txt = ["ä»€ä¹ˆæ„æ€ï¼Ÿ", "ä»€ä¹ˆæ„æ€ï¼", "æ„æ€ä»€ä¹ˆï¼Ÿ", "å•Šï¼Ÿï¼Ÿ"][count % 4] + "\n".repeat(count % 3);
                    this.bubble.innerText = txt; this.bubble.classList.add("visible");
                    if (count > 25) {
                        clearInterval(this.loopTimer); this.loopTimer = null;
                        this.speak("å˜£ï¼ï¼ï¼ï¼ï¼CPUè¿‡è½½... é‡å¯å®Œæˆã€‚", "explode");
                        setTimeout(() => this.visual.setState("idle"), 4000);
                    }
                }, 80);
            }
        }

        // --- å¯åŠ¨ ---
        const visual = new VisualEngine('main-canvas');
        const brain = new Brain(visual);

        document.body.addEventListener('click', () => { if (window.speechSynthesis) window.speechSynthesis.speak(new SpeechSynthesisUtterance(" ")); }, { once: true });

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const micBtn = document.getElementById('mic-btn');
        const statusText = document.getElementById('status-text');

        if (SpeechRecognition) {
            const recognition = new SpeechRecognition();
            recognition.lang = 'zh-CN'; recognition.continuous = false;
            recognition.onstart = () => { micBtn.classList.add('active'); statusText.innerText = "æ­£åœ¨è†å¬..."; };
            recognition.onend = () => { micBtn.classList.remove('active'); statusText.innerText = "ç‚¹å‡»éº¦å…‹é£å”¤é†’"; };
            recognition.onresult = (event) => { brain.think(event.results[0][0].transcript); };
            micBtn.onclick = () => { try { recognition.start(); } catch(e) { recognition.stop(); } };
        } else {
            statusText.innerText = "æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³"; micBtn.style.display = "none";
        }
    </script>
</body>
</html>
