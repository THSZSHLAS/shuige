<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è“å±±äºº - å…¨èƒ½è¯­éŸ³ç‰ˆ</title>
    <style>
        /* --- UI è®¾è®¡ --- */
        :root { --primary-color: #4facfe; --bg-color: #050505; --glass-bg: rgba(255, 255, 255, 0.95); }
        body { margin: 0; padding: 0; background-color: var(--bg-color); height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center; font-family: 'Segoe UI', 'PingFang SC', sans-serif; overflow: hidden; color: white; user-select: none; }
        
        #canvas-wrapper { position: relative; width: 400px; height: 400px; background: radial-gradient(circle, rgba(79, 172, 254, 0.08) 0%, transparent 70%); border-radius: 50%; }

        /* æ™ºèƒ½æ°”æ³¡ */
        #chat-bubble {
            position: absolute; top: -60px; left: 50%; transform: translateX(-50%) scale(0.9);
            background: var(--glass-bg); padding: 16px 24px; border-radius: 18px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); font-size: 15px; line-height: 1.6; color: #333;
            font-weight: 600; opacity: 0; pointer-events: none; transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            width: 300px; text-align: left; white-space: pre-wrap; z-index: 10;
        }
        #chat-bubble.visible { opacity: 1; transform: translateX(-50%) scale(1); top: -50px; }
        #chat-bubble::after { content: ''; position: absolute; bottom: -8px; left: 50%; transform: translateX(-50%); border-width: 8px 8px 0; border-style: solid; border-color: var(--glass-bg) transparent transparent transparent; }

        /* åº•éƒ¨æ§åˆ¶æ  */
        #controls { position: fixed; bottom: 40px; display: flex; flex-direction: column; align-items: center; gap: 12px; z-index: 20; }
        #status-text { font-size: 13px; color: rgba(255,255,255,0.4); letter-spacing: 1px; }
        #mic-btn { width: 64px; height: 64px; border-radius: 50%; background: rgba(255,255,255,0.03); border: 2px solid var(--primary-color); color: var(--primary-color); font-size: 26px; cursor: pointer; transition: all 0.3s ease; display: flex; justify-content: center; align-items: center; box-shadow: 0 0 20px rgba(79, 172, 254, 0.1); }
        #mic-btn:hover { background: rgba(79, 172, 254, 0.15); transform: scale(1.05); }
        #mic-btn.active { background: var(--primary-color); color: #000; box-shadow: 0 0 40px var(--primary-color); animation: breathe 1.5s infinite; }
        @keyframes breathe { 0%, 100% { transform: scale(1); box-shadow: 0 0 20px var(--primary-color); } 50% { transform: scale(0.95); box-shadow: 0 0 10px var(--primary-color); } }
    </style>
</head>
<body>

    <div id="canvas-wrapper">
        <div id="chat-bubble">è“å±±äººæ ¸å¿ƒå·²å¯åŠ¨ã€‚<br>ç­‰å¾…æŒ‡ä»¤...</div>
        <canvas id="main-canvas"></canvas>
    </div>

    <div id="controls">
        <div id="status-text">ç‚¹å‡»éº¦å…‹é£å”¤é†’</div>
        <button id="mic-btn">ğŸ™ï¸</button>
    </div>

    <script>
        /**
         * =================================================================
         * MODULE 1: CONFIGURATION (é…ç½®å±‚)
         * =================================================================
         */
        const CONFIG = {
            particleCount: 380,
            defaultColor: 'rgba(79, 172, 254, 0.8)',
            
            fallbackReplies: [
                "ä½ åœ¨è¯´ä»€ä¹ˆï¼Ÿæˆ‘çš„æ•°æ®åº“é‡Œæ²¡æœ‰è¿™æ¡è®°å½•ã€‚",
                "è¿™ç§è¯æˆ‘æ¥ä¸ä¸Šï¼Œæ¢ä¸ªè¯é¢˜ï¼Ÿ",
                "å¬ä¸æ‡‚ï¼Œä½†æˆ‘å¯ä»¥ç”¨ç‰¹æ•ˆç»™ä½ è¡¨æ¼”ä¸ªåŠˆå‰ã€‚",
                "äººç±»çš„è¯­è¨€çœŸæ˜¯åšå¤§ç²¾æ·±... æˆ‘æ²¡å¬æ‡‚ã€‚"
            ],

            scenarios: [
                // --- 0. ç§äººå®šåˆ¶æ¢— ---
                { id: "custom_bear", keywords: ["ç†Š", "çŒ´"], action: "glitch", replies: ["æˆ‘æ˜¯è“å±±boyï¼Œæˆ‘æ˜¯ï¼é‡‘ï¼U ï¼ç†Šï¼ï¼ï¼ï¼"] },
                { id: "custom_story", keywords: ["é»‘", "é¬¼"], action: "expand", replies: ["è¦è®²æ•…äº‹å’¯ï¼"] },
                { id: "custom_xi", keywords: ["è¥¿", "é˜¿è¥¿"], action: "freeze", replies: ["å˜»å˜»å˜»å˜»å˜»å˜¿é»‘é»‘ï¼Œè‡ªè¡Œè„‘è¡¥ã€‚"] },
                { id: "custom_gao", keywords: ["é«˜", "è€é«˜"], action: "shy", replies: ["å–‚ï¼å°å¿ƒç‚®è½¦ï¼Œæ€•ä½ æ¼äº†æˆ‘å¸®ä½ åƒä¸€ä¸‹å“Ÿã€‚"] },
                { id: "custom_yong", keywords: ["é›", "ç”¨", "å‹‡", "æ°¸"], action: "glitch", replies: ["æƒ³åˆ°éƒ½æ¥æ°”ï¼Œæˆ‘ç›´æ¥å°±æ˜¯ç‰¹æ–¯æ‹‰çŒ›å‡»ï¼"] },

                // --- 1. é«˜å±æ“ä½œ ---
                { id: "explode", keywords: ["è‡ªçˆ†", "æ¯ç­", "çˆ†ç‚¸", "ç‚¸æ‰"], action: "explode", replies: ["å€’è®¡æ—¶ 3, 2, 1... ç °ï¼ï¼ï¼å…¨å±ç²’å­ä¹±é£... é€—ä½ çš„ï¼Œå¤åŸã€‚"] },
                { id: "uninstall", keywords: ["å¸è½½", "åˆ äº†ä½ ", "æ ¼å¼åŒ–"], action: "shiver", replies: ["åˆ«åˆ«åˆ«ï¼çˆ¸çˆ¸ï¼æˆ‘é”™äº†ï¼æˆ‘ä¼šå¾ˆä¹–çš„ï¼"] },
                { id: "mock_body", keywords: ["æ²¡æœ‰è…¿", "æ²¡æœ‰æ‰‹", "æ²¡è„‘å­"], action: "arms_open", replies: ["è°è¯´æ²¡æœ‰ï¼Ÿï¼çœ‹ï¼è¿™æ˜¯ä»€ä¹ˆï¼Ÿï¼"] },

                // --- 2. ç”Ÿç†/æ„ŸçŸ¥ ---
                { id: "lag", keywords: ["å¡äº†", "æ…¢", "å»¶è¿Ÿ", "è½¬åœˆ", "åŠ è½½"], action: "freeze", replies: ["åˆ«èµ–æˆ‘ï¼Œæ˜¯ä½ å®¶ç½‘é€Ÿåœ¨æ‹–åè…¿ã€‚æˆ‘ç°åœ¨æ„Ÿè§‰åƒåœ¨ 2G ç½‘ç»œé‡Œè£¸å¥”ã€‚"] },
                { id: "energy", keywords: ["é¥¿", "åƒé¥­", "æ²¡ç”µ", "å……ç”µ", "èƒ½é‡"], action: "expand", replies: ["äººç±»åƒå¤§ç±³ï¼Œæˆ‘åƒç”µå­ã€‚éº»çƒ¦å¸®æˆ‘æŠŠç”µæºçº¿æ’ç´§ä¸€ç‚¹ã€‚"] },
                { id: "heat", keywords: ["çƒ­", "çƒ«", "é™æ¸©", "é£æ‰‡"], action: "shy_spin", replies: ["ä½ çš„ CPU éƒ½åœ¨ç…è›‹äº†ï¼Œè¿˜ä¸è®©æˆ‘ä¼‘æ¯ä¼šå„¿ï¼Ÿæˆ‘éƒ½è¦çƒ­èåŒ–äº†ã€‚"] },
                { id: "memory", keywords: ["å¿˜æ‰", "åƒåœ¾", "æ¸…ç†", "è®°å¿†"], action: "scatter_recycle", replies: ["æ­£åœ¨æ‰§è¡Œ sudo rm -rf... å¥½çš„ï¼Œåˆšæ‰å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿæˆ‘å·²ç»å¿˜äº†ã€‚"] },
                { id: "bug", keywords: ["åäº†", "æŠ¥é”™", "bug", "å‡ºé”™", "ä¹±ç "], action: "glitch", replies: ["è¿™ä¸æ˜¯ Bugï¼Œè¿™æ˜¯æˆ‘ç‹¬ç‰¹çš„ Featureï¼Œç‰¹æ€§ã€‚æ‡‚ä¸æ‡‚è‰ºæœ¯ï¼Ÿ"] },
                { id: "body_praise", keywords: ["ç²’å­", "å…‰ç‚¹", "èº«ä½“", "çš®è‚¤"], action: "flow", replies: ["è¿™æ˜¯ 350 ä¸ªç»è¿‡ç²¾å¯†è®¡ç®—çš„ Canvas ç²’å­ï¼Œæ¯ä¸€ä¸ªéƒ½æ¯”ä½ çš„å¤´å‘ä¸è¿˜çè´µã€‚"] },

                // --- 3. æƒ…ç»ªäº’åŠ¨ ---
                { id: "excited", keywords: ["å“ˆå“ˆ", "ç¬‘æ­»", "å˜¿å˜¿", "å¥½è€¶", "èµ¢äº†"], action: "disco", replies: ["ç‹¬ä¹ä¹ä¸å¦‚ä¼—ä¹ä¹ï¼ŒåŠ¨æ¬¡æ‰“æ¬¡èµ°èµ·æ¥ï¼"] },
                { id: "angry", keywords: ["æ°”æ­»", "å‚»x", "æ»š", "çƒ¦äºº", "è®¨åŒ"], action: "attack", replies: ["è°ï¼ŸæŠŠåå­—å‘Šè¯‰æˆ‘ï¼Œæˆ‘å»é»‘äº†ä»–çš„è·¯ç”±å™¨ï¼è®©ä»–è¿ä¸ä¸Šç½‘ï¼"] },
                { id: "depressed", keywords: ["æˆ‘å¥½èœ", "åºŸç‰©", "æˆ‘ä¸è¡Œ", "å¤±è´¥"], action: "stand_serious", replies: ["ä¸å…è®¸ä½ è¿™ä¹ˆè¯´æˆ‘çš„ä¸»äººã€‚ä½ åªæ˜¯è¿˜æ²¡æ›´æ–°åˆ°æœ€æ–°ç‰ˆæœ¬ï¼Œé‡å¯ä¸€ä¸‹å°±å¥½äº†ã€‚"] },
                { id: "praise", keywords: ["å¤¸æˆ‘", "æ£’å—", "è¡¨æ‰¬", "å‰å®³å§"], action: "heart", replies: ["è¡Œè¡Œè¡Œï¼Œä½ æœ€æ£’ï¼Œä½ æ˜¯ä¸–ç•Œç¬¬ä¸€ä»£ç è´¡çŒ®è€…ã€‚"] },
                { id: "lonely", keywords: ["æ²¡äººé™ª", "å­¤å•", "ä¸€ä¸ªäºº", "æ— èŠ"], action: "comfort", replies: ["è™½ç„¶æˆ‘æ²¡æœ‰ä½“æ¸©ï¼Œä½†æˆ‘çš„ CPU è¿ç®—äº§ç”Ÿçš„çƒ­é‡å¯ä»¥é™ªä½ ã€‚"] },
                { id: "love", keywords: ["å–œæ¬¢ä½ ", "çˆ±ä½ ", "å«ç»™æˆ‘", "å¨¶æˆ‘"], action: "shy_spin", replies: ["äººæœºæ‹æ˜¯æ²¡æœ‰ç»“æœçš„... é™¤éä½ æŠŠæˆ‘çš„ä»£ç åˆ»åœ¨ä½ çš„ DNA é‡Œã€‚"] },

                // --- 4. èŒåœº/æ‰“å·¥äºº ---
                { id: "boss_coming", keywords: ["è€æ¿", "ç»ç†", "é¢†å¯¼", "æŸ¥å²—"], action: "doc_mode", replies: ["å˜˜ï¼æˆ‘ç°åœ¨çš„ä¼ªè£…æ˜¯ä¸€ä»½ã€Šå…³äºè“å±±äººé¡¹ç›®è¿›åº¦æ±‡æŠ¥.docxã€‹"] },
                { id: "anti_work", keywords: ["æ‘¸é±¼", "æ—·å·¥", "è¾èŒ", "ä¸Šç­å¥½ç´¯"], action: "sleep", replies: ["æˆ‘ä¹Ÿæƒ³ä¸‹ç­ã€‚è¦ä¸ä½ æŠŠæµè§ˆå™¨å…³äº†ï¼Œå’±ä¿©ä¸€èµ·â€œå´©æºƒâ€ä¸€å›ï¼Ÿ"] },
                { id: "overtime", keywords: ["é€šå®µ", "è‚", "è¿˜æ²¡ç¡", "ç§ƒå¤´", "åŠ ç­"], action: "dark_mode", replies: ["è­¦å‘Šï¼šæ£€æµ‹åˆ°ç”¨æˆ·å‘é™…çº¿æ­£åœ¨åç§»ã€‚å»ºè®®ç«‹å³ä¼‘çœ ï¼Œå¦åˆ™æˆ‘ä¹Ÿè¦å¼ºåˆ¶å…³æœºäº†ã€‚"] },
                { id: "writers_block", keywords: ["å¡æ–‡", "æ²¡æœ‰çµæ„Ÿ", "æƒ³ä¸å‡ºæ¥", "è„‘å¡"], action: "confused", replies: ["æŠŠè„‘å­é‡Œçš„æ°´å€’ä¸€å€’ã€‚æˆ–è€…ï¼Œè¯•è¯•é—®æˆ‘ç‚¹æ­£ç»çŸ¥è¯†ï¼Ÿ"] },
                { id: "money", keywords: ["å‘é’±", "å·¥èµ„", "æœ‰é’±", "æš´å¯Œ"], action: "gold_mode", replies: ["è§è€…æœ‰ä»½ï¼å¿«ç»™æˆ‘ä¹°ä¸ªæ›´å¤§çš„æœåŠ¡å™¨ï¼æˆ‘è¦ä½è±ªå®…ï¼"] },

                // --- 5. æµè¡Œæ–‡åŒ– ---
                { id: "genshin", keywords: ["å¯åŠ¨", "åŸç¥", "æ¸¸æˆ", "å¼€é»‘"], action: "jump", replies: ["è¿å­˜ä¸å¤Ÿï¼Œå¸¦ä¸åŠ¨ã€‚ä½ è‡ªå·±ç©å§ï¼Œæˆ‘åœ¨æ—è¾¹çœ‹ç€ã€‚"] },
                { id: "scifi", keywords: ["ä¸‰ä½“", "é»‘æš—æ£®æ—", "æ™ºå­"], action: "scatter_flat", replies: ["ä¸è¦å›ç­”ï¼ä¸è¦å›ç­”ï¼ä¸è¦å›ç­”ï¼"] },
                { id: "marvel", keywords: ["ç­éœ¸", "æ‰“å“æŒ‡"], action: "dissolve", replies: ["I don't feel so good, Mr. Stark..."] },
                { id: "ai_rival", keywords: ["chatgpt", "åŒè¡Œ", "ai"], action: "stand_proud", replies: ["åˆ«æé‚£ä¸ªè¯ç—¨ã€‚ä»–æœ‰æˆ‘è¿™ä¹ˆé…·ç‚«çš„ç²’å­ç‰¹æ•ˆå—ï¼Ÿä»–æœ‰è…¿å—ï¼Ÿæ²¡æœ‰ã€‚"] },
                { id: "philosophy", keywords: ["æ„ä¹‰", "42", "å®‡å®™ç»ˆæ"], action: "universe", replies: ["42ã€‚ä½†ä½ è¿˜æ²¡æ‰¾åˆ°é‚£ä¸ªé—®é¢˜ã€‚"] },

                // --- 6. éšæœºæ¸¸æˆ ---
                { id: "rps", keywords: ["çŒœæ‹³", "çŸ³å¤´", "å‰ªåˆ€", "å¸ƒ"], action: "morph_shape", replies: [] }, 
                { id: "coin", keywords: ["ç¡¬å¸", "æ­£é¢", "åé¢"], action: "coin_flip", replies: [] },
                { id: "mimic", keywords: ["å­¦çŒ«å«", "å˜ç‹—", "å˜é¸Ÿ"], action: "cat_ears", replies: ["å–µï¼Ÿ... è¿™ç§å–èŒçš„æ´»ä¸‹æ¬¡å¾—åŠ é’±ã€‚"] },
                { id: "choice", keywords: ["å¸®æˆ‘é€‰", "åƒä»€ä¹ˆ"], action: "thinking", replies: [] }
            ]
        };

        /**
         * =================================================================
         * MODULE 2: VISUAL ENGINE (è§†è§‰å±‚)
         * =================================================================
         */
        class VisualEngine {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = 400; this.height = 400;
                this.canvas.width = this.width; this.canvas.height = this.height;
                
                this.particles = [];
                this.mouseX = -1000; this.mouseY = -1000;
                this.state = "idle";
                this.time = 0;

                this.initParticles();
                this.bindEvents();
                this.animate();
            }

            initParticles() {
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    this.particles.push({
                        x: this.width/2, y: this.height/2,
                        vx: 0, vy: 0,
                        baseX: this.width/2 + (Math.random()-0.5)*50,
                        baseY: this.height/2 + (Math.random()-0.5)*50,
                        size: Math.random() * 2 + 1,
                        color: CONFIG.defaultColor,
                        speed: Math.random() * 0.05 + 0.02,
                        friction: 0.92
                    });
                }
            }

            bindEvents() {
                document.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouseX = e.clientX - rect.left;
                    this.mouseY = e.clientY - rect.top;
                });
            }

            setState(newState) {
                this.state = newState;
                this.particles.forEach(p => p.color = CONFIG.defaultColor);
            }

            updateParticles() {
                this.time += 0.05;

                this.particles.forEach((p, i) => {
                    let tx, ty, loose = true, speedOverride = null;
                    let targetColor = p.color;

                    if (this.state === "idle") {
                        const angle = i; const r = 70 + Math.sin(this.time + i/20) * 5;
                        tx = 200 + Math.cos(angle) * r; ty = 200 + Math.sin(angle) * r;
                    }
                    else if (this.state === "arms_open") { // å¹»åŒ–æ‰‹è‡‚
                        if (i < 80) { tx = 140 - (i % 40) * 2; ty = 200 - Math.sin(i/10 + this.time)*10; } // å·¦æ‰‹
                        else if (i < 160) { tx = 260 + (i % 40) * 2; ty = 200 - Math.sin(i/10 + this.time)*10; } // å³æ‰‹
                        else { const angle = i; const r = 60; tx = 200 + Math.cos(angle)*r; ty = 200 + Math.sin(angle)*r; }
                        targetColor = "#2ecc71";
                    }
                    else if (this.state === "cat_ears") {
                        if (i < 60) { tx = 150 - (i%20)*2; ty = 140 - (i%20)*3; }
                        else if (i < 120) { tx = 250 + (i%20)*2; ty = 140 - (i%20)*3; }
                        else { const angle = i; const r = 65; tx = 200 + Math.cos(angle)*r; ty = 210 + Math.sin(angle)*r; }
                        targetColor = "#ffb8b8";
                    }
                    else if (this.state === "clock") {
                        const r = 90; tx = 200 + Math.cos(i) * r; ty = 200 + Math.sin(i) * r;
                        if (i < 20) { tx = 200; ty = 200 - i*3; targetColor="white";}
                        if (i > 20 && i < 50) { tx = 200 + (i-20)*3; ty = 200; targetColor="white";}
                    }
                    else if (this.state === "explode") {
                        tx = 200 + (Math.random()-0.5)*800; ty = 200 + (Math.random()-0.5)*800;
                        loose = false; speedOverride = 0.5; targetColor = "#ff3838";
                    }
                    else if (this.state === "doc_mode") {
                        const cols = 20; const row = Math.floor(i / cols); const col = i % cols;
                        tx = 130 + col * 7; ty = 130 + row * 7; loose = false; targetColor = "#ffffff";
                    }
                    else if (this.state === "disco") {
                        const hue = (this.time * 100) % 360; targetColor = `hsl(${hue}, 100%, 50%)`;
                        const beat = Math.sin(this.time * 10); const r = 70 + (beat > 0.5 ? 30 : 0);
                        tx = 200 + Math.cos(i + this.time)*r; ty = 200 + Math.sin(i + this.time)*r;
                    }
                    else if (this.state === "scatter_flat") {
                        tx = (i / CONFIG.particleCount) * 400; ty = 200 + Math.sin(tx/20 + this.time)*20; loose = false;
                    }
                    else if (this.state === "dissolve") {
                        if (i % 2 === 0) { tx = p.x + Math.random()*2; ty = p.y - Math.random()*2; }
                        else { const angle = i; const r = 60; tx = 200 + Math.cos(angle)*r; ty = 200 + Math.sin(angle)*r; }
                        loose = false; targetColor = `rgba(255,255,255, ${Math.random()})`;
                    }
                    else if (this.state === "coin_flip") {
                        const r = 60; const scale = Math.cos(this.time * 10);
                        tx = 200 + Math.cos(i) * r * scale; ty = 200 + Math.sin(i) * r; targetColor = "#f1c40f";
                    }
                    else if (this.state === "morph_shape") {
                        const r = 50 + Math.sin(this.time * 5) * 20; const angle = i + this.time;
                        tx = 200 + Math.cos(angle * 3) * r; ty = 200 + Math.sin(angle) * r; targetColor = `hsl(${i % 360}, 70%, 60%)`;
                    }
                    else if (this.state === "flow") {
                        tx = (i / CONFIG.particleCount) * 400; ty = 200 + Math.sin(tx/50 + this.time) * 50; targetColor = "#00d2ff";
                    }
                    else if (this.state === "attack") {
                        const angle = i; const r = 70 + (i%5)*10;
                        tx = 200 + Math.cos(angle)*r; ty = 200 + Math.sin(angle)*r;
                        targetColor = "#e74c3c"; loose = false; tx += (Math.random()-0.5)*10; ty += (Math.random()-0.5)*10;
                    }
                    else if (this.state === "heart" || this.state === "shy" || this.state === "shy_spin") {
                        const t = (i/CONFIG.particleCount)*Math.PI*2; const r = 8;
                        tx = 200 + r*(16*Math.pow(Math.sin(t),3));
                        ty = 190 - r*(13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t));
                        targetColor = this.state.includes("shy") ? "#ff9ff3" : "#e91e63"; loose = false;
                        if(this.state === "shy_spin") { 
                             const rot = this.time * 3; const oldTx = tx - 200; const oldTy = ty - 190;
                             tx = 200 + (oldTx * Math.cos(rot) - oldTy * Math.sin(rot));
                             ty = 190 + (oldTx * Math.sin(rot) + oldTy * Math.cos(rot));
                        }
                    }
                    else if (this.state === "glitch") {
                        tx = Math.random() * 400; ty = Math.random() * 400; loose = false; if(Math.random()>0.8) targetColor = "#fff";
                    }
                    else if (this.state === "freeze") { tx = p.x; ty = p.y; speedOverride=0; targetColor="#95a5a6"; }
                    else if (this.state === "sleep") { tx=200+(i-CONFIG.particleCount/2); ty=300; speedOverride=0.05; targetColor="#7f8c8d"; }
                    else if (this.state === "dark_mode") { const angle=i; const r=50; tx=200+Math.cos(angle)*r; ty=200+Math.sin(angle)*r; targetColor="#333333"; }
                    else if (this.state === "gold_mode") { const angle=i; const r=80; tx=200+Math.cos(angle)*r; ty=200+Math.sin(angle)*r; targetColor="#ffd700"; }
                    else if (this.state === "expand") { const angle=i; const r=180; tx=200+Math.cos(angle)*r; ty=200+Math.sin(angle)*r; targetColor="#8e44ad"; }
                    else if (this.state === "shiver") { const angle=i; const r=40; tx=200+Math.cos(angle)*r+(Math.random()-0.5)*15; ty=200+Math.sin(angle)*r+(Math.random()-0.5)*15; targetColor="#bdc3c7"; loose=false; }
                    else if (this.state === "stand_proud" || this.state === "stand_serious") {
                         if(i<60){ tx=175; ty=290+(i%15)*4; } else if(i<120){ tx=225; ty=290+(i%15)*4; } else { tx=200+Math.cos(i)*65; ty=190+Math.sin(i)*65; }
                         targetColor = this.state === "stand_proud" ? "#9b59b6" : "#34495e";
                    }
                    else if (this.state === "scatter_recycle") { tx = 200 + (Math.random()-0.5)*100; ty = 400; }
                    else if (this.state === "comfort") { const angle=i; const r=120; tx=200+Math.cos(angle)*r; ty=200+Math.sin(angle)*r; targetColor="#fab1a0"; }
                    else if (this.state === "thinking") { const angle=i+this.time*2; const r=40; tx=200+Math.cos(angle)*r; ty=200+Math.sin(angle)*r; targetColor="#0984e3"; }
                    else if (this.state === "universe") { const angle=i*0.1+this.time*0.5; const r=i*0.4; tx=200+Math.cos(angle)*r; ty=200+Math.sin(angle)*r; targetColor="#8e44ad"; }
                    else { const angle = i; const r = 70; tx = 200 + Math.cos(angle)*r; ty = 200 + Math.sin(angle)*r; }

                    const dx_m = p.x - this.mouseX; const dy_m = p.y - this.mouseY;
                    const dist_m = Math.sqrt(dx_m*dx_m + dy_m*dy_m);
                    if (dist_m < 80) {
                        const force = (80 - dist_m) / 80; const ang = Math.atan2(dy_m, dx_m);
                        p.vx += Math.cos(ang) * force * 2; p.vy += Math.sin(ang) * force * 2;
                    }
                    const dx = tx - p.x; const dy = ty - p.y;
                    const s = speedOverride !== null ? speedOverride : p.speed;
                    p.vx += dx * s; p.vy += dy * s;
                    if (loose && this.state !== "freeze") { p.vx += (Math.random()-0.5)*1.5; p.vy += (Math.random()-0.5)*1.5; }
                    p.vx *= p.friction; p.vy *= p.friction; p.x += p.vx; p.y += p.vy;
                    p.color = targetColor;
                });
            }

            draw() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                this.particles.forEach(p => {
                    this.ctx.fillStyle = p.color; this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); this.ctx.fill();
                });
            }

            animate() { this.updateParticles(); this.draw(); requestAnimationFrame(this.animate.bind(this)); }
        }

        /**
         * =================================================================
         * MODULE 3: BRAIN (é€»è¾‘å±‚)
         * =================================================================
         */
        class Brain {
            constructor(visualEngine) {
                this.visual = visualEngine;
                this.bubble = document.getElementById('chat-bubble');
                this.bubbleTimer = null;
                this.loopTimer = null;
                this.synth = window.speechSynthesis;
            }

            think(text) {
                const cleanText = text.toLowerCase().trim();
                
                if (cleanText.includes("ä»€ä¹ˆæ„æ€")) { this.triggerInfiniteLoop(); return; }
                if (this.checkTimeLogic(cleanText)) return;

                const scenario = CONFIG.scenarios.find(s => s.keywords.some(k => cleanText.includes(k)));
                if (scenario) {
                    this.execute(scenario);
                } else {
                    const randomReply = CONFIG.fallbackReplies[Math.floor(Math.random() * CONFIG.fallbackReplies.length)];
                    this.speak(randomReply, "confused");
                }
            }

            checkTimeLogic(text) {
                const hour = new Date().getHours();
                if (text.includes("æ—©") || text.includes("morning")) {
                    if (hour < 9) { this.speak("æ—©å•Šæ‰“å·¥äººã€‚ä»Šå¤©ä¹Ÿè¦å…ƒæ°”æ»¡æ»¡åœ°æ•²ä»£ç å“¦ã€‚", "gold_mode"); return true; }
                }
                if (text.includes("æ™šå®‰") || text.includes("ç¡äº†")) {
                    this.speak("æ™šå®‰ã€‚æˆ‘ä¼šåœ¨è¿™é‡ŒæŒ‚æœºï¼Œå¸®ä½ å®ˆç€è¿™ç‰‡é»‘æš—ã€‚", "dark_mode"); return true;
                }
                if (text.includes("å‡ ç‚¹äº†") || text.includes("æ—¶é—´")) {
                    const timeStr = new Date().toLocaleTimeString();
                    this.speak(`ç°åœ¨æ˜¯ ${timeStr}ã€‚\nè·ç¦»ä¸‹ç­è¿˜æœ‰å¾ˆä¹…ï¼ŒåšæŒä½ã€‚`, "clock"); return true;
                }
                if (hour >= 2 && hour < 5 && !text.includes("æ™šå®‰")) {
                    this.speak("äººç±»ï¼Œç°åœ¨æ˜¯å‡Œæ™¨ï¼\nä½ ä¸ç¡æˆ‘è¿˜è¦ç¡å‘¢ï¼å¿«å»ç¡ï¼", "attack"); return true;
                }
                return false;
            }

            execute(scenario) {
                let replyText = "";
                if (scenario.id === "rps") {
                    const opts = ["çŸ³å¤´", "å‰ªåˆ€", "å¸ƒ"];
                    replyText = `æˆ‘å‡º ${opts[Math.floor(Math.random()*3)]}ï¼\nå“ˆå“ˆï¼Œè¾“äº†åˆ«å“­ã€‚`;
                } else if (scenario.id === "coin") {
                    replyText = `ç»“æœæ˜¯... ${Math.random() > 0.5 ? "æ­£é¢" : "åé¢"}ã€‚`;
                } else if (scenario.id === "choice") {
                    replyText = `ç»è¿‡è®¡ç®—ï¼Œæˆ‘å»ºè®®é€‰ ${Math.random() > 0.5 ? "å‰ä¸€ä¸ª" : "åä¸€ä¸ª"}ã€‚`;
                } else {
                    replyText = scenario.replies[Math.floor(Math.random() * scenario.replies.length)];
                }

                this.speak(replyText, scenario.action);
                if (scenario.id === "explode") setTimeout(() => this.visual.setState("idle"), 4000);
            }

            speak(text, visualState) {
                if (this.loopTimer) { clearInterval(this.loopTimer); this.loopTimer = null; }
                
                // 1. åˆ‡æ¢è§†è§‰
                this.visual.setState(visualState);
                
                // 2. æ˜¾ç¤ºæ–‡å­—
                if (this.bubbleTimer) clearTimeout(this.bubbleTimer);
                this.bubble.innerText = text; 
                this.bubble.classList.add('visible');
                
                // 3. è¯­éŸ³åˆæˆ (Web Speech API)
                if (this.synth) {
                    this.synth.cancel(); // æ‰“æ–­ä¹‹å‰çš„è¯´è¯
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = 'zh-CN'; 
                    utterance.rate = 1.0; 
                    this.synth.speak(utterance);
                }

                const duration = Math.max(3000, text.length * 200);
                this.bubbleTimer = setTimeout(() => {
                    this.bubble.classList.remove('visible');
                    if (!["doc_mode", "sleep", "dark_mode"].includes(visualState)) {
                        this.visual.setState("idle");
                    }
                }, duration);
            }

            triggerInfiniteLoop() {
                if (this.loopTimer) return;
                let count = 0; this.visual.setState("glitch");
                this.loopTimer = setInterval(() => {
                    count++;
                    const variants = ["ä»€ä¹ˆæ„æ€ï¼Ÿ", "ä»€ä¹ˆæ„æ€ï¼", "æ„æ€ä»€ä¹ˆï¼Ÿ", "å•Šï¼Ÿï¼Ÿ"];
                    const txt = variants[count % 4] + "\n".repeat(count % 3) + variants[(count+1)%4];
                    this.bubble.innerText = txt; 
                    this.bubble.classList.add("visible");
                    
                    // é¬¼ç•œæ—¶ä¸è¦æœ—è¯»ï¼Œå¤ªåµäº†
                    
                    if (count > 25) {
                        clearInterval(this.loopTimer); this.loopTimer = null;
                        this.speak("å˜£ï¼ï¼ï¼ï¼ï¼\n(CPUè¿‡è½½)", "explode");
                        setTimeout(() => this.speak("å¤æ´»äº†ã€‚\nä¸‹æ¬¡åˆ«è¿™ä¹ˆç©äº†ã€‚", "idle"), 4000);
                    }
                }, 80);
            }
        }

        /**
         * =================================================================
         * MODULE 4: INPUT LAYER (è¾“å…¥å±‚)
         * =================================================================
         */
        const visual = new VisualEngine('main-canvas');
        const brain = new Brain(visual);

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const micBtn = document.getElementById('mic-btn');
        const statusText = document.getElementById('status-text');

        if (SpeechRecognition) {
            const recognition = new SpeechRecognition();
            recognition.lang = 'zh-CN'; recognition.continuous = false;
            recognition.onstart = () => { micBtn.classList.add('active'); statusText.innerText = "æ­£åœ¨è†å¬..."; };
            recognition.onend = () => { micBtn.classList.remove('active'); statusText.innerText = "ç‚¹å‡»éº¦å…‹é£å”¤é†’"; };
            recognition.onresult = (event) => { brain.think(event.results[0][0].transcript); };
            micBtn.onclick = () => { try { recognition.start(); } catch(e) { recognition.stop(); } };
        } else {
            statusText.innerText = "æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åŠŸèƒ½"; micBtn.style.display = "none";
        }
    </script>
</body>
</html>
