<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è“å±±äºº</title> 
    <style>
        /*å¾ªç¯ä¼˜åŒ–ç‰ˆ*/
        /* --- UI (ä¿æŒä¸å˜) --- */
        :root { --primary-color: #4facfe; --bg-color: #050505; --glass-bg: rgba(255, 255, 255, 0.95); }
        body { margin: 0; padding: 0; background-color: var(--bg-color); height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center; font-family: 'Segoe UI', 'PingFang SC', sans-serif; overflow: hidden; color: white; user-select: none; -webkit-tap-highlight-color: transparent; }
        #canvas-wrapper { position: relative; width: 350px; height: 350px; background: radial-gradient(circle, rgba(79, 172, 254, 0.08) 0%, transparent 70%); border-radius: 50%; }
        #chat-bubble { position: absolute; top: -60px; left: 50%; transform: translateX(-50%) scale(0.9); background: var(--glass-bg); padding: 16px 24px; border-radius: 18px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); font-size: 15px; line-height: 1.6; color: #333; font-weight: 600; opacity: 0; pointer-events: none; transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); width: 280px; text-align: left; white-space: pre-wrap; z-index: 10; }
        #chat-bubble.visible { opacity: 1; transform: translateX(-50%) scale(1); top: -50px; }
        #chat-bubble::after { content: ''; position: absolute; bottom: -8px; left: 50%; transform: translateX(-50%); border-width: 8px 8px 0; border-style: solid; border-color: var(--glass-bg) transparent transparent transparent; }
        #controls { position: fixed; bottom: 40px; display: flex; flex-direction: column; align-items: center; gap: 15px; z-index: 20; }
        #status-text { font-size: 13px; color: rgba(255,255,255,0.4); letter-spacing: 1px; }
        .btn-group { display: flex; gap: 15px; }
        #mic-btn, #setting-btn, #mute-btn { width: 56px; height: 56px; border-radius: 50%; background: rgba(255,255,255,0.05); border: 2px solid var(--primary-color); color: var(--primary-color); font-size: 22px; cursor: pointer; transition: all 0.3s ease; display: flex; justify-content: center; align-items: center; box-shadow: 0 0 20px rgba(79, 172, 254, 0.1); }
        #setting-btn { border-color: #fab1a0; color: #fab1a0; font-size: 20px; }
        #mute-btn { border-color: #81ecec; color: #81ecec; font-size: 20px; }
        #mic-btn:active, #setting-btn:active, #mute-btn:active { transform: scale(0.95); }
        #mic-btn.active { background: var(--primary-color); color: #000; box-shadow: 0 0 40px var(--primary-color); animation: breathe 1.5s infinite; }
        #voice-panel { position: fixed; bottom: 120px; left: 50%; transform: translateX(-50%) translateY(20px); width: 80%; max-width: 300px; background: rgba(20, 20, 20, 0.95); border: 1px solid #333; border-radius: 15px; padding: 15px; display: none; flex-direction: column; gap: 10px; opacity: 0; transition: all 0.3s; backdrop-filter: blur(10px); z-index: 30; }
        #voice-panel.open { display: flex; opacity: 1; transform: translateX(-50%) translateY(0); }
        #voice-panel h3 { margin: 0; font-size: 14px; color: #aaa; text-align: center; }
        #voice-select { padding: 10px; border-radius: 8px; background: #333; color: white; border: none; outline: none; font-size: 14px; }
        #close-panel { background: var(--primary-color); border: none; padding: 8px; border-radius: 8px; color: #000; font-weight: bold; cursor: pointer; }
        @keyframes breathe { 0%, 100% { transform: scale(1); box-shadow: 0 0 20px var(--primary-color); } 50% { transform: scale(0.95); box-shadow: 0 0 10px var(--primary-color); } }
    </style>
</head>
<body>

    <div id="canvas-wrapper">
        <div id="chat-bubble">å†…æ ¸é‡æ„å®Œæˆã€‚<br>é«˜æ€§èƒ½æ¨¡å¼è¿è¡Œä¸­ã€‚</div>
        <canvas id="main-canvas"></canvas>
    </div>

    <div id="voice-panel">
        <h3>é€‰æ‹©å£°éŸ³</h3>
        <select id="voice-select"></select>
        <button id="close-panel">ç¡®å®š</button>
    </div>

    <div id="controls">
        <div id="status-text">ç‚¹å‡»éº¦å…‹é£å”¤é†’</div>
        <div class="btn-group">
            <button id="mute-btn" title="å¼€å¯/å…³é—­è¯­éŸ³">ğŸ”Š</button>
            <button id="setting-btn" title="åˆ‡æ¢éŸ³è‰²">âš™ï¸</button>
            <button id="mic-btn" title="æŒ‰ä½è¯´è¯">ğŸ™ï¸</button>
        </div>
    </div>

    <script>
        /**
         * =================================================================
         * MODULE 1: CONFIG & STATE STRATEGIES (é…ç½®ä¸ç­–ç•¥)
         * =================================================================
         */
        const CONFIG = {
            particleCount: 380,
            defaultColor: 'rgba(79, 172, 254, 0.8)',
            fallbackReplies: ["æ•°æ®åº“æœªå‘½ä¸­ã€‚", "å†è¯´ä¸€éï¼Ÿ", "å¬ä¸æ‡‚ï¼Œç»™ä½ è¡¨æ¼”ä¸ªåŠˆå‰ã€‚"],
            
            // æ—¶é—´å›å¤é…ç½®
            timeResponses: {
                morning_early: { action: "gold_mode", text: "æ—©å•Šæ‰“å·¥äººã€‚ä»Šå¤©ä¹Ÿè¦å…ƒæ°”æ»¡æ»¡åœ°æ•²ä»£ç å“¦ã€‚" },
                morning_late: { action: "confused", text: "é†’é†’ï¼Œè¿™éƒ½å‡ ç‚¹äº†è¿˜æ—©å®‰ï¼Ÿå¤ªé˜³éƒ½æ™’å±è‚¡äº†ã€‚" },
                night: { action: "dark_mode", text: "æ™šå®‰ã€‚æˆ‘ä¼šåœ¨è¿™é‡ŒæŒ‚æœºï¼Œå¸®ä½ å®ˆç€è¿™ç‰‡é»‘æš—ã€‚" },
                late_night_scold: { action: "attack", text: "äººç±»ï¼Œç°åœ¨æ˜¯å‡Œæ™¨ï¼ä½ ä¸ç¡æˆ‘è¿˜è¦ç¡å‘¢ï¼å¿«å»ç¡ï¼" },
                ask_time: { action: "clock", text: "ç°åœ¨æ˜¯ {time}ã€‚è·ç¦»ä¸‹ç­è¿˜æœ‰å¾ˆä¹…ï¼ŒåšæŒä½ã€‚" }
            },

            // åœºæ™¯åˆ—è¡¨
            scenarios: [
                // 0. æ–°å¢æƒ…æ™¯
                { id: "cmd_stand", keywords: ["ç«™èµ·æ¥", "ç«™"], action: "stand_proud", replies: ["è¦æˆ‘ç«™èµ·æ¥å¹²å˜› å‘†ç“œ"] },
                { id: "cmd_sit", keywords: ["å", "åä¸‹"], action: "sleep", replies: ["éš”è¿™è®­ç‹—å‘¢ ä½ ä»–å¦ˆçš„"] },
                { id: "cmd_name", keywords: ["è“å±±äºº"], action: "stand_proud", replies: ["æˆ‘è¦æ’æ­»ä½ "] },
                // 1. åŠ¨ä½œç±»
                { id: "wave", keywords: ["æŒ¥æ‰‹", "æ‹›æ‰‹", "æ‹œæ‹œ"], action: "wave_hand", replies: ["(æŒ¥åŠ¨ç²’å­æ‰‹è‡‚) å—¨ï¼çœ‹åˆ°æˆ‘äº†å—ï¼Ÿ"] },
                { id: "jump", keywords: ["è·³", "èµ·é£", "è¹¦"], action: "jump_ball", replies: ["èŠœæ¹–ï¼èµ·é£ï¼"] },
                { id: "salute", keywords: ["æ•¬ç¤¼", "æ”¶åˆ°", "yes sir"], action: "salute", replies: ["Yes Sir! ä¿è¯å®Œæˆä»»åŠ¡ï¼"] },
                { id: "wake", keywords: ["çå¼€çœ¼", "ççœ¼", "é†’é†’"], action: "open_eyes", replies: ["ğŸ‘€ æ—©å°±é†’å•¦ï¼"] },
                // 2. ç§äººå®šåˆ¶
                { id: "bear", keywords: ["ç†Š", "çŒ´"], action: "glitch", replies: ["æˆ‘æ˜¯è“å±±boyï¼Œæˆ‘æ˜¯ï¼é‡‘ï¼U ï¼ç†Šï¼ï¼ï¼ï¼"] },
                { id: "story", keywords: ["é»‘", "é¬¼"], action: "expand", replies: ["è¦è®²æ•…äº‹å’¯ï¼"] },
                { id: "xi", keywords: ["è¥¿", "é˜¿è¥¿"], action: "freeze", replies: ["å˜»å˜»å˜»å˜»å˜»å˜¿é»‘é»‘ï¼Œè‡ªè¡Œè„‘è¡¥ã€‚"] },
                { id: "gao", keywords: ["é«˜", "è€é«˜"], action: "shy", replies: ["å–‚ï¼å°å¿ƒç‚®è½¦ï¼Œæ€•ä½ æ¼äº†æˆ‘å¸®ä½ åƒä¸€ä¸‹å“Ÿã€‚"] },
                { id: "yong", keywords: ["é›", "ç”¨", "å‹‡", "æ°¸"], action: "glitch", replies: ["æƒ³åˆ°éƒ½æ¥æ°”ï¼Œæˆ‘ç›´æ¥å°±æ˜¯ç‰¹æ–¯æ‹‰çŒ›å‡»ï¼"] },
                // 3. é€šç”¨æŒ‡ä»¤
                { id: "explode", keywords: ["è‡ªçˆ†", "æ¯ç­", "çˆ†ç‚¸"], action: "explode", replies: ["å€’è®¡æ—¶ 3, 2, 1... ç °ï¼ï¼ï¼"] },
                { id: "mock_body", keywords: ["æ²¡æœ‰è…¿", "æ²¡æœ‰æ‰‹"], action: "arms_open", replies: ["è°è¯´æ²¡æœ‰ï¼Ÿï¼çœ‹ï¼è¿™æ˜¯ä»€ä¹ˆï¼Ÿï¼"] },
                { id: "energy", keywords: ["é¥¿", "åƒé¥­", "æ²¡ç”µ"], action: "expand", replies: ["äººç±»åƒå¤§ç±³ï¼Œæˆ‘åƒç”µå­ã€‚"] },
                { id: "heat", keywords: ["çƒ­", "çƒ«", "é™æ¸©"], action: "shy_spin", replies: ["æˆ‘éƒ½è¦çƒ­èåŒ–äº†ã€‚"] },
                { id: "bug", keywords: ["åäº†", "æŠ¥é”™", "bug"], action: "glitch", replies: ["è¿™ä¸æ˜¯ Bugï¼Œè¿™æ˜¯ Featureã€‚"] },
                { id: "disco", keywords: ["å“ˆå“ˆ", "å˜¿å˜¿", "å¥½è€¶"], action: "disco", replies: ["ç‹¬ä¹ä¹ä¸å¦‚ä¼—ä¹ä¹ï¼Œå—¨èµ·æ¥ï¼"] },
                { id: "attack", keywords: ["æ°”æ­»", "å‚»x", "æ»š"], action: "attack", replies: ["è°ï¼Ÿæˆ‘å»é»‘äº†ä»–çš„è·¯ç”±å™¨ï¼"] },
                { id: "heart", keywords: ["å¤¸æˆ‘", "æ£’å—", "è¡¨æ‰¬"], action: "heart", replies: ["è¡Œè¡Œè¡Œï¼Œä½ æœ€æ£’ã€‚"] },
                { id: "love", keywords: ["å–œæ¬¢ä½ ", "çˆ±ä½ "], action: "shy_spin", replies: ["äººæœºæ‹æ˜¯æ²¡æœ‰ç»“æœçš„..."] },
                { id: "doc", keywords: ["è€æ¿", "ç»ç†", "æŸ¥å²—"], action: "doc_mode", replies: ["å˜˜ï¼ä¼ªè£…æˆæ–‡æ¡£æ¨¡å¼ã€‚"] },
                { id: "sleep", keywords: ["æ‘¸é±¼", "ä¸‹ç­", "ç´¯"], action: "sleep", replies: ["æˆ‘ä¹Ÿæƒ³ä¸‹ç­ã€‚"] },
                { id: "dark", keywords: ["é€šå®µ", "è‚", "ç§ƒå¤´"], action: "dark_mode", replies: ["è­¦å‘Šï¼šæ£€æµ‹åˆ°å‘é™…çº¿åç§»ã€‚"] },
                { id: "gold", keywords: ["å‘é’±", "å·¥èµ„", "æš´å¯Œ"], action: "gold_mode", replies: ["è§è€…æœ‰ä»½ï¼"] },
                // éšæœºç±»
                { id: "rps", keywords: ["çŒœæ‹³", "çŸ³å¤´", "å‰ªåˆ€"], action: "morph_shape", replies: [] },
                { id: "coin", keywords: ["ç¡¬å¸", "æ­£é¢", "åé¢"], action: "coin_flip", replies: [] },
                { id: "choice", keywords: ["å¸®æˆ‘é€‰", "åƒä»€ä¹ˆ"], action: "thinking", replies: [] }
            ]
        };

        /**
         * âš¡ï¸ é«˜æ€§èƒ½çŠ¶æ€ç­–ç•¥è¡¨ (State Strategies)
         * å°†å‡ ä½•è®¡ç®—é€»è¾‘ä»å¾ªç¯ä¸­æŠ½ç¦»ï¼Œé€šè¿‡æŸ¥è¡¨è°ƒç”¨ï¼Œé¿å…å·¨å¤§çš„ switch/if-else
         * å‚æ•°: p (ç²’å­), i (ç´¢å¼•), env (å…¨å±€ç¯å¢ƒæ•°æ®: time, mouseX, mouseY)
         */
        const STATE_STRATEGIES = {
            // 1. åŸºç¡€ & èº«ä½“éƒ¨ä½
            idle: (p, i, env) => {
                const angle = i; const r = 70 + Math.sin(env.time + i/20) * 5;
                return { tx: 175 + Math.cos(angle)*r, ty: 175 + Math.sin(angle)*r };
            },
            arms_open: (p, i, env) => { // ä¼¸æ‰‹
                if (i < 80) return { tx: 115 - (i%40)*2, ty: 175 - Math.sin(i/10 + env.time)*10, color: "#2ecc71" };
                if (i < 160) return { tx: 235 + (i%40)*2, ty: 175 - Math.sin(i/10 + env.time)*10, color: "#2ecc71" };
                const angle = i; const r = 60; return { tx: 175 + Math.cos(angle)*r, ty: 175 + Math.sin(angle)*r, color: "#2ecc71" };
            },
            wave_hand: (p, i, env) => { // æŒ¥æ‰‹
                if (i < 50) {
                    const waveSpeed = env.time * 8;
                    const handX = 240 + Math.cos(waveSpeed) * 30;
                    const handY = 150 + Math.sin(waveSpeed) * 30 - Math.abs(Math.sin(waveSpeed)*15);
                    return { tx: handX + (Math.random()-0.5)*15, ty: handY + (Math.random()-0.5)*15, color: "#ffffff", loose: false };
                }
                const angle = i; const r = 65; return { tx: 175 + Math.cos(angle)*r, ty: 175 + Math.sin(angle)*r };
            },
            salute: (p, i, env) => { // æ•¬ç¤¼
                if (i < 40) return { tx: 210 + (Math.random()-0.5)*20, ty: 130 + (Math.random()-0.5)*10, color: "#ffffff", loose: false };
                const angle = i; return { tx: 175 + Math.cos(angle)*60, ty: 185 + Math.sin(angle)*70, color: "#34495e" };
            },
            open_eyes: (p, i, env) => { // ççœ¼
                if (i < 20) return { tx: 145 + Math.cos(i)*5, ty: 155 + Math.sin(i)*5, color: "#ffffff", loose: false };
                if (i < 40) return { tx: 205 + Math.cos(i)*5, ty: 155 + Math.sin(i)*5, color: "#ffffff", loose: false };
                const angle = i; const r = 75; return { tx: 175 + Math.cos(angle)*r, ty: 175 + Math.sin(angle)*r };
            },
            jump_ball: (p, i, env) => { // è·³è·ƒ
                const bounce = Math.abs(Math.sin(env.time * 6)) * 150;
                const r = 35; const angle = i;
                return { tx: 175 + Math.cos(angle)*r, ty: 280 - bounce + Math.sin(angle)*r, color: "#f1c40f", speed: 0.2, loose: false };
            },
            // 2. å½¢çŠ¶å˜æ¢
            heart: (p, i, env) => {
                const t = (i/CONFIG.particleCount)*Math.PI*2; const r = 8;
                return {
                    tx: 175 + r*(16*Math.pow(Math.sin(t),3)),
                    ty: 165 - r*(13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t)),
                    color: "#e91e63", loose: false
                };
            },
            clock: (p, i, env) => {
                if (i < 20) return { tx: 175, ty: 175 - i*3, color: "white" };
                if (i < 50) return { tx: 175 + (i-20)*3, ty: 175, color: "white" };
                const r = 90; return { tx: 175 + Math.cos(i)*r, ty: 175 + Math.sin(i)*r };
            },
            cat_ears: (p, i, env) => {
                if (i < 60) return { tx: 125-(i%20)*2, ty: 115-(i%20)*3, color: "#ffb8b8" };
                if (i < 120) return { tx: 225+(i%20)*2, ty: 115-(i%20)*3, color: "#ffb8b8" };
                const angle = i; const r = 65; return { tx: 175 + Math.cos(angle)*r, ty: 185 + Math.sin(angle)*r, color: "#ffb8b8" };
            },
            // 3. ç‰¹æ•ˆç±»
            explode: (p, i, env) => ({ tx: 175 + (Math.random()-0.5)*800, ty: 175 + (Math.random()-0.5)*800, color: "#ff3838", speed: 0.5, loose: false }),
            glitch: (p, i, env) => ({ tx: Math.random()*350, ty: Math.random()*350, color: Math.random()>0.8 ? "#fff" : p.color, loose: false }),
            freeze: (p, i, env) => ({ tx: p.x, ty: p.y, color: "#95a5a6", speed: 0 }),
            shy_spin: (p, i, env) => {
                const angle = i + env.time * 3; const r = 80;
                return { tx: 175 + Math.cos(angle)*r, ty: 175 + Math.sin(angle)*r, color: "#ff9ff3", loose: false };
            },
            shy: (p, i, env) => {
                const angle = i; const r = 80;
                return { tx: 175 + Math.cos(angle)*r, ty: 175 + Math.sin(angle)*r, color: "#ff9ff3", loose: false };
            },
            disco: (p, i, env) => {
                const hue = (env.time * 100) % 360;
                const r = 70 + (Math.sin(env.time*10) > 0.5 ? 30 : 0);
                return { tx: 175 + Math.cos(i+env.time)*r, ty: 175 + Math.sin(i+env.time)*r, color: `hsl(${hue}, 100%, 50%)` };
            },
            // 4. çŠ¶æ€ç±»
            doc_mode: (p, i, env) => {
                const cols = 20; const row = Math.floor(i / cols); const col = i % cols;
                return { tx: 105 + col * 7, ty: 105 + row * 7, color: "#ffffff", loose: false };
            },
            sleep: (p, i, env) => ({ tx: 175 + (i - CONFIG.particleCount/2), ty: 275, color: "#7f8c8d", speed: 0.05 }),
            expand: (p, i, env) => { const angle = i; const r = 150; return { tx: 175 + Math.cos(angle)*r, ty: 175 + Math.sin(angle)*r, color: "#8e44ad" }; },
            shiver: (p, i, env) => {
                const angle = i; const r = 40;
                return { tx: 175 + Math.cos(angle)*r + (Math.random()-0.5)*15, ty: 175 + Math.sin(angle)*r + (Math.random()-0.5)*15, color: "#bdc3c7", loose: false };
            },
            scatter_recycle: (p, i, env) => ({ tx: 175 + (Math.random()-0.5)*100, ty: 400 }),
            stand_proud: (p, i, env) => {
                if(i<60) return { tx: 150, ty: 290+(i%15)*4, color: "#9b59b6" };
                if(i<120) return { tx: 200, ty: 290+(i%15)*4, color: "#9b59b6" };
                return { tx: 175 + Math.cos(i)*65, ty: 190 + Math.sin(i)*65, color: "#9b59b6" };
            },
            stand_serious: (p, i, env) => {
                if(i<60) return { tx: 150, ty: 290+(i%15)*4, color: "#34495e" };
                if(i<120) return { tx: 200, ty: 290+(i%15)*4, color: "#34495e" };
                return { tx: 175 + Math.cos(i)*65, ty: 190 + Math.sin(i)*65, color: "#34495e" };
            },
            attack: (p, i, env) => {
                const angle = i; const r = 70+(i%5)*10;
                return { tx: 175 + Math.cos(angle)*r + (Math.random()-0.5)*10, ty: 175 + Math.sin(angle)*r + (Math.random()-0.5)*10, color: "#e74c3c", loose: false };
            },
            gold_mode: (p, i, env) => { const angle=i; const r=80; return { tx: 175+Math.cos(angle)*r, ty: 175+Math.sin(angle)*r, color: "#ffd700" }; },
            dark_mode: (p, i, env) => { const angle=i; const r=50; return { tx: 175+Math.cos(angle)*r, ty: 175+Math.sin(angle)*r, color: "#333333" }; },
            comfort: (p, i, env) => { const angle=i; const r=120; return { tx: 175+Math.cos(angle)*r, ty: 175+Math.sin(angle)*r, color: "#fab1a0" }; },
            thinking: (p, i, env) => { const angle=i+env.time*2; const r=40; return { tx: 175+Math.cos(angle)*r, ty: 175+Math.sin(angle)*r, color: "#0984e3" }; },
            universe: (p, i, env) => { const angle=i*0.1+env.time*0.5; const r=i*0.4; return { tx: 175+Math.cos(angle)*r, ty: 175+Math.sin(angle)*r, color: "#8e44ad" }; },
            coin_flip: (p, i, env) => { const r=60; const s=Math.cos(env.time*10); return { tx: 175+Math.cos(i)*r*s, ty: 175+Math.sin(i)*r, color: "#f1c40f" }; },
            morph_shape: (p, i, env) => { const r=50+Math.sin(env.time*5)*20; const angle=i+env.time; return { tx: 175+Math.cos(angle*3)*r, ty: 175+Math.sin(angle)*r, color: `hsl(${i%360},70%,60%)` }; },
            flow: (p, i, env) => { return { tx: (i/CONFIG.particleCount)*400, ty: 175+Math.sin((i/CONFIG.particleCount)*400/50 + env.time)*50, color: "#00d2ff" }; },
            scatter_flat: (p, i, env) => { return { tx: (i/CONFIG.particleCount)*350, ty: 175+Math.sin((i/CONFIG.particleCount)*350/20 + env.time)*20, loose: false }; },
            dissolve: (p, i, env) => {
                if(i%2===0) return { tx: p.x+Math.random()*2, ty: p.y-Math.random()*2, color: `rgba(255,255,255,${Math.random()})`, loose: false };
                const angle=i; const r=60; return { tx: 175+Math.cos(angle)*r, ty: 175+Math.sin(angle)*r, color: `rgba(255,255,255,${Math.random()})`, loose: false };
            }
        };

        /**
         * =================================================================
         * MODULE 2: VISUAL ENGINE (è§†è§‰å±‚ - ä¼˜åŒ–ç‰ˆ)
         * =================================================================
         */
        class VisualEngine {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = 350; this.height = 350;
                this.canvas.width = this.width; this.canvas.height = this.height;
                
                this.particles = [];
                this.mouseX = -1000; this.mouseY = -1000;
                this.state = "idle";
                this.time = 0;
                this.isBreathing = false;

                this.initParticles();
                this.bindEvents();
                this.animate();
            }

            initParticles() {
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    this.particles.push({
                        x: this.width/2, y: this.height/2, vx: 0, vy: 0,
                        baseX: this.width/2 + (Math.random()-0.5)*50,
                        baseY: this.height/2 + (Math.random()-0.5)*50,
                        size: Math.random() * 2 + 1,
                        color: CONFIG.defaultColor,
                        speed: Math.random() * 0.05 + 0.02,
                        friction: 0.92
                    });
                }
            }

            bindEvents() {
                const updateMouse = (x, y) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouseX = x - rect.left;
                    this.mouseY = y - rect.top;
                };
                document.addEventListener('mousemove', (e) => updateMouse(e.clientX, e.clientY));
                document.addEventListener('touchmove', (e) => updateMouse(e.touches[0].clientX, e.touches[0].clientY), {passive: true});
            }

            setState(newState) { this.state = newState; }
            setBreathing(flag) { this.isBreathing = flag; }

            // *** æ ¸å¿ƒä¼˜åŒ–å¾ªç¯ ***
            updateParticles() {
                this.time += 0.05;
                
                // è·å–å½“å‰çŠ¶æ€çš„è®¡ç®—å‡½æ•°ï¼Œé»˜è®¤ idle
                const strategy = STATE_STRATEGIES[this.state] || STATE_STRATEGIES.idle;
                
                // é¢„å°è£…ç¯å¢ƒæ•°æ®
                const env = { time: this.time, mouseX: this.mouseX, mouseY: this.mouseY };

                // å‘¼å¸å› å­ (0 ~ 0.06)
                const breathScale = this.isBreathing ? (1 + Math.sin(this.time * 8) * 0.06) : 1;

                for (let i = 0; i < this.particles.length; i++) {
                    const p = this.particles[i];
                    
                    // 1. è·å–ç›®æ ‡ä½ç½® (Strategy Pattern)
                    let res = strategy(p, i, env);
                    
                    // é»˜è®¤å€¼å¡«å……
                    if (!res.color) res.color = p.color;
                    if (res.loose === undefined) res.loose = true;
                    if (res.speed === undefined) res.speed = p.speed;

                    // 2. åº”ç”¨å‘¼å¸æ•ˆæœ (å…¨å±€ç¼©æ”¾)
                    if (this.isBreathing && res.loose) {
                        res.tx = 175 + (res.tx - 175) * breathScale;
                        res.ty = 175 + (res.ty - 175) * breathScale;
                    }

                    // 3. ç‰©ç†è®¡ç®— (å‡å°‘é—­åŒ…å’Œé‡å¤å¼•ç”¨)
                    const dx_m = p.x - this.mouseX;
                    const dy_m = p.y - this.mouseY;
                    
                    // ç®€å•çš„è·ç¦»æ£€æŸ¥ï¼Œé¿å… sqrt å¼€æ–¹ (ä½¿ç”¨å¹³æ–¹æ¯”è¾ƒ)
                    const distSq_m = dx_m * dx_m + dy_m * dy_m;
                    
                    if (distSq_m < 6400) { // 80*80
                        const dist_m = Math.sqrt(distSq_m);
                        const force = (80 - dist_m) / 80;
                        const ang = Math.atan2(dy_m, dx_m);
                        p.vx += Math.cos(ang) * force * 2;
                        p.vy += Math.sin(ang) * force * 2;
                    }

                    const dx = res.tx - p.x;
                    const dy = res.ty - p.y;
                    
                    p.vx += dx * res.speed;
                    p.vy += dy * res.speed;

                    if (res.loose && this.state !== "freeze") {
                        p.vx += (Math.random() - 0.5) * 1.5;
                        p.vy += (Math.random() - 0.5) * 1.5;
                    }

                    p.vx *= p.friction;
                    p.vy *= p.friction;
                    p.x += p.vx;
                    p.y += p.vy;
                    p.color = res.color;
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                for (let i = 0; i < this.particles.length; i++) {
                    const p = this.particles[i];
                    this.ctx.fillStyle = p.color;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            animate() { this.updateParticles(); this.draw(); requestAnimationFrame(this.animate.bind(this)); }
        }

        /**
         * =================================================================
         * MODULE 3: BRAIN (é€»è¾‘å±‚ - ä¼˜åŒ–ç‰ˆ)
         * =================================================================
         */
        class Brain {
            constructor(visualEngine) {
                this.visual = visualEngine;
                this.bubble = document.getElementById('chat-bubble');
                this.bubbleTimer = null;
                this.loopTimer = null;
                this.synth = window.speechSynthesis;
                this.selectedVoice = null;
                this.voiceEnabled = true;
                
                // *** ä¼˜åŒ–ï¼šé¢„æ„å»ºå…³é”®è¯ç´¢å¼• (Flattened Index) ***
                this.keywordIndex = [];
                CONFIG.scenarios.forEach(scenario => {
                    scenario.keywords.forEach(kw => {
                        this.keywordIndex.push({ keyword: kw, scenario: scenario });
                    });
                });

                this.initVoiceSystem();
                this.bindControls();
            }

            bindControls() {
                const muteBtn = document.getElementById('mute-btn');
                muteBtn.addEventListener('click', () => {
                    this.voiceEnabled = !this.voiceEnabled;
                    muteBtn.innerText = this.voiceEnabled ? "ğŸ”Š" : "ğŸ”‡";
                    if (!this.voiceEnabled && this.synth) this.synth.cancel();
                });
            }

            initVoiceSystem() {
                const populateVoices = () => {
                    if (!this.synth) return;
                    const voices = this.synth.getVoices().filter(v => v.lang.includes('zh') || v.lang.includes('CN'));
                    const select = document.getElementById('voice-select');
                    select.innerHTML = '';
                    if (voices.length === 0) { select.innerHTML = '<option>é»˜è®¤è¯­éŸ³</option>'; return; }
                    voices.forEach((v, index) => { const opt = document.createElement('option'); opt.text = v.name; opt.value = index; select.add(opt); });
                    this.selectedVoice = voices[0];
                    select.onchange = (e) => { this.selectedVoice = voices[e.target.value]; };
                };
                populateVoices();
                if (this.synth.onvoiceschanged !== undefined) this.synth.onvoiceschanged = populateVoices;
                
                const panel = document.getElementById('voice-panel');
                document.getElementById('setting-btn').onclick = () => panel.classList.add('open');
                document.getElementById('close-panel').onclick = () => panel.classList.remove('open');
            }

            think(text) {
                const cleanText = text.toLowerCase().trim();
                if (cleanText.includes("ä»€ä¹ˆæ„æ€")) { this.triggerInfiniteLoop(); return; }
                if (this.checkTimeLogic(cleanText)) return;

                // *** ä¼˜åŒ–ï¼šå•æ¬¡éå† ***
                const match = this.keywordIndex.find(item => cleanText.includes(item.keyword));
                
                if (match) {
                    this.execute(match.scenario);
                } else {
                    const reply = CONFIG.fallbackReplies[Math.floor(Math.random() * CONFIG.fallbackReplies.length)];
                    this.speak(reply, "confused");
                }
            }

            checkTimeLogic(text) {
                const h = new Date().getHours();
                if (text.includes("æ—©") || text.includes("morning")) {
                    const res = (h < 9) ? CONFIG.timeResponses.morning_early : CONFIG.timeResponses.morning_late;
                    this.speak(res.text, res.action); return true;
                }
                if (text.includes("æ™šå®‰") || text.includes("ç¡äº†")) {
                    this.speak(CONFIG.timeResponses.night.text, CONFIG.timeResponses.night.action); return true;
                }
                if (text.includes("å‡ ç‚¹") || text.includes("æ—¶é—´")) {
                    this.speak(CONFIG.timeResponses.ask_time.text.replace("{time}", new Date().toLocaleTimeString()), "clock"); return true;
                }
                if (h >= 2 && h < 5 && !text.includes("æ™šå®‰")) {
                    this.speak(CONFIG.timeResponses.late_night_scold.text, "attack"); return true;
                }
                return false;
            }

            execute(scenario) {
                let reply = "";
                // åŠ¨æ€é€»è¾‘ä¾ç„¶ä¿ç•™
                if (scenario.id === "rps") { reply = `æˆ‘å‡º ${["çŸ³å¤´","å‰ªåˆ€","å¸ƒ"][Math.floor(Math.random()*3)]}ï¼`; }
                else if (scenario.id === "coin") { reply = `ç»“æœæ˜¯... ${Math.random()>0.5?"æ­£é¢":"åé¢"}ã€‚`; }
                else if (scenario.id === "choice") { reply = `å»ºè®®é€‰ ${Math.random()>0.5?"å‰ä¸€ä¸ª":"åä¸€ä¸ª"}ã€‚`; }
                else { reply = scenario.replies[Math.floor(Math.random() * scenario.replies.length)]; }
                
                this.speak(reply, scenario.action);
                if (scenario.id === "explode") setTimeout(() => this.visual.setState("idle"), 4000);
            }

            speak(text, visualState) {
                if (this.loopTimer) { clearInterval(this.loopTimer); this.loopTimer = null; }
                
                this.visual.setState(visualState);
                if (this.bubbleTimer) clearTimeout(this.bubbleTimer);
                
                this.bubble.innerText = text; this.bubble.classList.add('visible');
                this.visual.setBreathing(true);

                if (this.voiceEnabled && this.synth) {
                    this.synth.cancel();
                    const utt = new SpeechSynthesisUtterance(text);
                    if (this.selectedVoice) utt.voice = this.selectedVoice;
                    this.synth.speak(utt);
                }

                const dur = Math.max(3000, text.length * 200);
                this.bubbleTimer = setTimeout(() => {
                    this.bubble.classList.remove('visible');
                    this.visual.setBreathing(false);
                    if (!["doc_mode", "sleep", "dark_mode"].includes(visualState)) this.visual.setState("idle");
                }, dur);
            }

            triggerInfiniteLoop() {
                if (this.loopTimer) return;
                let count = 0; this.visual.setState("glitch");
                this.loopTimer = setInterval(() => {
                    count++;
                    const txt = ["ä»€ä¹ˆæ„æ€ï¼Ÿ", "ä»€ä¹ˆæ„æ€ï¼", "æ„æ€ä»€ä¹ˆï¼Ÿ", "å•Šï¼Ÿï¼Ÿ"][count % 4] + "\n".repeat(count % 3);
                    this.bubble.innerText = txt; this.bubble.classList.add("visible");
                    if (count > 25) {
                        clearInterval(this.loopTimer); this.loopTimer = null;
                        this.speak("å˜£ï¼ï¼ï¼ï¼ï¼CPUè¿‡è½½", "explode");
                        setTimeout(() => this.speak("å¤æ´»äº†ã€‚", "idle"), 4000);
                    }
                }, 80);
            }
        }

        // --- Init ---
        const visual = new VisualEngine('main-canvas');
        const brain = new Brain(visual);

        document.body.addEventListener('click', () => { if (window.speechSynthesis) window.speechSynthesis.speak(new SpeechSynthesisUtterance(" ")); }, { once: true });

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const micBtn = document.getElementById('mic-btn');
        const statusText = document.getElementById('status-text');

        if (SpeechRecognition) {
            const recognition = new SpeechRecognition();
            recognition.lang = 'zh-CN'; recognition.continuous = false;
            recognition.onstart = () => { micBtn.classList.add('active'); statusText.innerText = "æ­£åœ¨è†å¬..."; };
            recognition.onend = () => { micBtn.classList.remove('active'); statusText.innerText = "ç‚¹å‡»éº¦å…‹é£å”¤é†’"; };
            recognition.onresult = (e) => { brain.think(e.results[0][0].transcript); };
            micBtn.onclick = () => { try { recognition.start(); } catch(e) { recognition.stop(); } };
        } else {
            statusText.innerText = "æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³"; micBtn.style.display = "none";
        }
    </script>
</body>
</html>
