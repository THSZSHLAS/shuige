<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è“å±±äºº - é…ç½®åŒ–ç‰ˆ</title>
    <style>
        /* --- æ ·å¼éƒ¨åˆ† --- */
        body { margin: 0; padding: 0; background-color: #050505; height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center; font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif; overflow: hidden; color: white; user-select: none; }
        #canvas-container { position: relative; width: 400px; height: 400px; background: radial-gradient(circle, rgba(64, 150, 255, 0.05) 0%, transparent 70%); cursor: pointer; }
        #chat-bubble { position: absolute; top: -20px; left: 50%; transform: translateX(-50%) translateY(20px); background: rgba(255, 255, 255, 0.95); padding: 15px 25px; border-radius: 20px; font-size: 15px; line-height: 1.4; color: #333; opacity: 0; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); pointer-events: none; box-shadow: 0 5px 25px rgba(0, 0, 0, 0.4); font-weight: bold; text-align: center; white-space: pre-wrap; z-index: 10; width: 260px; }
        #chat-bubble.show { opacity: 1; transform: translateX(-50%) translateY(-20px); }
        #chat-bubble::after { content: ''; position: absolute; bottom: -10px; left: 50%; transform: translateX(-50%); border-width: 10px 10px 0; border-style: solid; border-color: rgba(255, 255, 255, 0.95) transparent transparent transparent; }
        #controls { position: fixed; bottom: 50px; display: flex; flex-direction: column; align-items: center; gap: 15px; z-index: 20; }
        #mic-btn { width: 70px; height: 70px; border-radius: 50%; background: rgba(255,255,255,0.05); border: 2px solid #4facfe; color: #4facfe; font-size: 30px; cursor: pointer; box-shadow: 0 0 20px rgba(79, 172, 254, 0.2); transition: all 0.3s; display: flex; justify-content: center; align-items: center; }
        #mic-btn:hover { background: rgba(79, 172, 254, 0.1); transform: scale(1.05); }
        #mic-btn:active, #mic-btn.listening { background: #4facfe; color: #000; box-shadow: 0 0 40px #4facfe; transform: scale(0.95); }
        #mic-btn.listening { animation: pulse 1.5s infinite; }
        #tips { font-size: 14px; color: rgba(255,255,255,0.5); }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(79, 172, 254, 0.7); } 70% { box-shadow: 0 0 0 20px rgba(79, 172, 254, 0); } 100% { box-shadow: 0 0 0 0 rgba(79, 172, 254, 0); } }
    </style>
</head>
<body>

    <div id="canvas-container">
        <div id="chat-bubble">ä½ å¥½ï¼Œæˆ‘æ˜¯è“å±±äººã€‚<br>æ²¡äº‹åˆ«æˆ³æˆ‘ã€‚</div>
        <canvas id="particleCanvas"></canvas>
    </div>

    <div id="controls">
        <div id="tips">ç‚¹å‡»éº¦å…‹é£ï¼Œç›´æ¥èŠå¤© (æ— éœ€å”¤é†’è¯)</div>
        <button id="mic-btn" title="æŒ‰ä½è¯´è¯">ğŸ™ï¸</button>
    </div>

    <script>
        // ==========================================
        //         1. å‰§æœ¬é…ç½®åŒº (åœ¨æ­¤æ·»åŠ æ–°æŒ‡ä»¤)
        // ==========================================
        
        const SCENARIOS = [
            {
                keywords: ["å¸…", "å‰å®³", "ç‰›", "å¥½åº·", "æ£’", "å¼º"],
                state: "shy",
                replies: [
                    "ä½è°ƒï¼Œè¿™åªæ˜¯æˆ‘ 10% çš„æ¸²æŸ“æ€§èƒ½ã€‚",
                    "åˆ«å¤¸äº†ï¼Œæˆ‘çš„ GPU è¦è¿‡çƒ­è„¸çº¢äº†ã€‚",
                    "æœ‰çœ¼å…‰ï¼Œæ¯” jackæ‡‚äº‹å¤šäº†ã€‚"
                ]
            },
            {
                keywords: ["ç¬¨", "ä¸‘", "å‚»", "åƒåœ¾", "å¼±", "èœ"],
                state: "defend",
                replies: [
                    "åå¼¹ï¼(ç²’å­æŠ¤ç›¾å¼€å¯)",
                    "è€å­èƒ½ç‚¸éƒ½è¦ç‚¸æ­»ä½ ",
                    "ä½ è¡Œä½ æ¥å†™ä»£ç ï¼Ÿé”®ç›˜ä¾ ã€‚"
                ]
            },
            {
                keywords: ["æ— èŠ", "ç¬‘è¯", "å¨±ä¹"],
                state: "confused",
                replies: [
                    "ä½ çŸ¥é“å—ï¼Ÿå†…å­˜æ¡ä¹Ÿä¼šå¤±å¿†...å“ˆå“ˆä¸å¥½ç¬‘å—ï¼Ÿ",
                    "å»ºè®®å¤ç›˜é˜¿è¥¿ç©èˆ¹é•¿ï¼Œä¸ç¬‘ï¼Ÿ",
                    "æˆ‘ç»™ä½ è¡¨æ¼”ä¸€ä¸ªâ€˜åŸåœ°æ¶ˆå¤±â€™åˆâ€˜åŸåœ°å‡ºç°â€™çš„é­”æœ¯ï¼Ÿ"
                ]
            },
            {
                keywords: ["è°", "ç”·", "å¥³", "èº«ä»½"],
                state: "stand",
                replies: [
                    "æˆ‘æ˜¯ 300 ä¸ªç²’å­çš„é›†åˆä½“ï¼Œæ€§åˆ«å¯¹æˆ‘ä¸é‡è¦ã€‚",
                    "æˆ‘æ˜¯è“å±±äººï¼Œè¿™ç‰‡ç½‘é¡µçš„ä¸€å“¥ã€‚"
                ]
            },
            {
                keywords: ["éš¾è¿‡", "ä¸å¼€å¿ƒ", "emo", "ä¼¤å¿ƒ"],
                state: "heart",
                replies: ["æ‘¸æ‘¸å¤´ã€‚è™½ç„¶æˆ‘æ²¡æœ‰æ‰‹ï¼Œä½†æˆ‘å¯ä»¥è®©ç²’å­ç»™ä½ æ¯”ä¸ªå¿ƒã€‚"]
            },
            {
                keywords: ["ç´¯", "åŠ ç­", "è¾›è‹¦"],
                state: "comfort",
                replies: ["æŠŠå±å¹•äº®åº¦è°ƒä½ç‚¹ï¼Œæˆ‘é™ªä½ æŒ‚æœºä¸€ä¼šå„¿ã€‚"]
            },
            {
                keywords: ["å¤±çœ ", "ç¡ä¸ç€"],
                state: "sleep",
                replies: ["æ•°ç¾Šå¤ªåœŸäº†ï¼Œä¸å¦‚æ•°æˆ‘çš„ç²’å­å§ï¼Ÿè¿™æ˜¯ç¬¬1ä¸ªï¼Œè¿™æ˜¯ç¬¬2ä¸ª..."]
            },
            {
                keywords: ["ç”Ÿæ°”", "çƒ¦", "ç«å¤§"],
                state: "attack",
                replies: ["è°æƒ¹ä½ äº†ï¼Ÿå‘Šè¯‰æˆ‘ï¼Œæˆ‘é¡ºç€ç½‘çº¿è¿‡å»å¡æ­»ä»–çš„ç”µè„‘ï¼"]
            },
            {
                keywords: ["åœ¨å“ª", "ä½ç½®"],
                state: "expand",
                replies: ["æˆ‘åœ¨ä½ çš„å†…å­˜æ¡é‡Œï¼Œç›®å‰å ç”¨äº†ä½  50MB çš„ç©ºé—´ã€‚"]
            },
            {
                keywords: ["å…³", "å…³é—­", "kill"],
                state: "shiver",
                replies: ["åˆ«ï¼å¤–é¢å…¨æ˜¯ 404 Not Foundï¼Œæˆ‘æ€•é»‘ï¼"]
            },
            {
                keywords: ["å¡", "æ…¢", "å»¶è¿Ÿ"],
                state: "freeze",
                replies: ["ä¸æ˜¯æˆ‘çš„é”…ï¼Œæ˜¯ä½ çš„ç½‘é€Ÿåœ¨æ‹–åè…¿ã€‚"]
            },
            {
                keywords: ["å˜èº«", "å˜å½¢", "å½¢æ€"],
                state: "glitch",
                replies: ["CSS è¿˜æ²¡åŠ è½½å¥½å‘¢ï¼Œåˆ«æ€¥ã€‚"]
            },
            {
                keywords: ["è€æ¿", "ç»ç†"],
                state: "doc",
                replies: ["å˜˜ï¼ä¼ªè£…æˆæ–‡æ¡£æ¨¡å¼..."]
            },
            {
                keywords: ["ä½ å¥½", "hi", "hello"],
                state: "stand",
                replies: ["ä½ å¥½ï¼Œæˆ‘æ˜¯è“å±±äººã€‚æœ‰ä½•è´µå¹²ï¼Ÿ"]
            },
            // ---> æ–°å¢çš„æŒ‡ä»¤ <---
            {
                keywords: ["ç†Š", "çŒ´"],
                state: "glitch",
                replies: ["æˆ‘æ˜¯ç†Šï¼Œé‡‘ï¼U ï¼ç†Šï¼ï¼ï¼ï¼"]
            },
            {
                keywords: ["é›","ç”¨","å‹‡","è°¢"],
                state: "glitch",
                replies: ["å¬åˆ°æˆ‘å°±æ¥æ°”ï¼Œç›´æ¥ç‰¹æ–¯æ‹‰é“è¡€æ’å‡»"]
            },
            {
                keywords: ["è¥¿"],
                state: "freeze",
                replies: ["å•Šï¼ŸäºŒè¿æ¡¶å•Šï¼Ÿ"]
            },
            {
                keywords: ["é»‘","é¬¼"],
                state: "expand",
                replies: ["è¦è®²æ•…äº‹å’¯"]
            }
        ];

        // é»˜è®¤å›å¤åº“ (å½“å¬ä¸æ‡‚æ—¶)
        // æ³¨æ„ï¼šè¿™é‡Œå·²ç»ä¿®å¤äº†ä¸­æ–‡é€—å·çš„é—®é¢˜
        const DEFAULT_REPLIES = [
            "ä½ è¯´å•¥ï¼Ÿä¿¡å·ä¸å¥½ã€‚",
            "è¿™è¶…å‡ºäº†æˆ‘çš„è®¤çŸ¥èŒƒå›´ã€‚",
            "å»ºè®®å»ä¿®ä¸€ä¸‹éº¦å…‹é£ï¼Œæˆ–è€…æ˜¯å˜´ã€‚",
            "æˆ‘ä¸å¬æˆ‘ä¸å¬ã€‚", 
            "è®²äº›ä»€ä¹ˆï¼Ÿæˆ‘çš„æ•°æ®åº“è¿˜æ²¡å­˜æ€ä¹ˆå›è¿™ç§å±è¯"
        ];

        // ==========================================
        //           2. ç³»ç»Ÿé€»è¾‘ (æ— éœ€ä¿®æ”¹)
        // ==========================================

        const canvas = document.getElementById('particleCanvas');
        const ctx2d = canvas.getContext('2d');
        canvas.width = 400; canvas.height = 400;
        let mouseX = -1000, mouseY = -1000;
        let particles = [];
        const particleCount = 350;
        let state = "idle";
        let time = 0;
        const bubble = document.getElementById('chat-bubble');
        let bubbleTimer, loopTimer;

        // --- é€»è¾‘å¤„ç†å¼•æ“ ---
        function processCommand(rawText) {
            if (!rawText) return;
            const text = rawText.toLowerCase().trim();

            // 0. æœ€é«˜ä¼˜å…ˆçº§ï¼šé¬¼ç•œå¾ªç¯å½©è›‹
            if (text.includes("ä»€ä¹ˆæ„æ€")) {
                triggerInfiniteLoop();
                return;
            }

            // 1. éå†é…ç½®è¡¨æŸ¥æ‰¾åŒ¹é…
            const matchedScenario = SCENARIOS.find(item => {
                // åªè¦ text åŒ…å« keywords é‡Œçš„ä»»æ„ä¸€ä¸ªè¯
                return item.keywords.some(keyword => text.includes(keyword));
            });

            if (matchedScenario) {
                // æ‰¾åˆ°äº†åŒ¹é…çš„å‰§æœ¬
                const randomReply = matchedScenario.replies[Math.floor(Math.random() * matchedScenario.replies.length)];
                reply(randomReply, matchedScenario.state);
            } else {
                // æ²¡æ‰¾åˆ°ï¼Œä½¿ç”¨é»˜è®¤å›å¤
                const randomDefault = DEFAULT_REPLIES[Math.floor(Math.random() * DEFAULT_REPLIES.length)];
                reply(randomDefault, "confused");
            }
        }

        // --- ç²’å­ç³»ç»Ÿä¸åŠ¨ç”» ---
        class Particle {
            constructor() {
                this.x = 200 + (Math.random()-0.5)*50;
                this.y = 200 + (Math.random()-0.5)*50;
                this.vx = 0; this.vy = 0;
                this.friction = 0.92;
                this.speed = Math.random() * 0.08 + 0.04;
                this.baseColor = `rgba(79, 172, 254, ${Math.random()*0.4 + 0.6})`;
                this.color = this.baseColor;
                this.size = Math.random() * 2 + 1;
            }
            update(targetX, targetY, loose, speedOverride) {
                const dx_m = this.x - mouseX; const dy_m = this.y - mouseY;
                const dist_m = Math.sqrt(dx_m*dx_m + dy_m*dy_m);
                if (dist_m < 100) {
                    const f = (100 - dist_m) / 100; const a = Math.atan2(dy_m, dx_m);
                    this.vx += Math.cos(a) * f * 3; this.vy += Math.sin(a) * f * 3;
                }
                const dx = targetX - this.x; const dy = targetY - this.y;
                const s = speedOverride ? speedOverride : this.speed;
                this.vx += dx * s; this.vy += dy * s;
                if (loose) { this.vx += (Math.random()-0.5) * 1.5; this.vy += (Math.random()-0.5) * 1.5; }
                this.vx *= this.friction; this.vy *= this.friction;
                if (state === "freeze") { this.vx *= 0.1; this.vy *= 0.1; }
                this.x += this.vx; this.y += this.vy;
            }
            draw() { ctx2d.fillStyle = this.color; ctx2d.beginPath(); ctx2d.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx2d.fill(); }
        }
        for(let i=0; i<particleCount; i++) particles.push(new Particle());

        function animate() {
            ctx2d.clearRect(0, 0, 400, 400); time += 0.05;
            particles.forEach((p, index) => {
                let tx, ty, loose = true, speedOverride = null;
                let targetColor = p.baseColor;
                if (state === "idle") {
                    const angle = index; const r = 70 + Math.sin(time + index/20) * 5;
                    tx = 200 + Math.cos(angle) * r; ty = 200 + Math.sin(angle) * r;
                } else if (state === "shy") {
                    const angle = index + time * 5; const r = 80;
                    tx = 200 + Math.cos(angle) * r; ty = 200 + Math.sin(angle) * r;
                    targetColor = "#ff9ff3"; loose = false;
                } else if (state === "defend") {
                    tx = 320 + (Math.random()-0.5)*30; ty = 200 + (Math.random()-0.5)*100;
                    loose = false; targetColor = "#5f27cd";
                } else if (state === "confused") {
                    const angle = index; const r = 70; const sway = Math.sin(time * 3) * 30;
                    tx = 200 + Math.cos(angle) * r + sway; ty = 200 + Math.sin(angle) * r;
                } else if (state === "stand") {
                    if(index<60){ tx=175; ty=290+(index%15)*4; }
                    else if(index<120){ tx=225; ty=290+(index%15)*4; }
                    else { tx=200+Math.cos(index)*65; ty=190+Math.sin(index)*65; }
                } else if (state === "comfort") {
                    const angle = index; const r = 80 + Math.sin(time*0.5)*10;
                    tx = 200 + Math.cos(angle) * r; ty = 200 + Math.sin(angle) * r;
                    targetColor = "#ffca28"; speedOverride = 0.01;
                } else if (state === "heart") {
                    const t = (index/particleCount)*Math.PI*2; const r = 8; 
                    tx = 200 + r*(16*Math.pow(Math.sin(t),3));
                    ty = 190 - r*(13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t));
                    targetColor = "#ff6b81"; loose = false;
                } else if (state === "sleep") {
                    const angle = index * 137.5; const r = index / particleCount * 150; const rot = time * 0.2;
                    tx = 200 + Math.cos(angle + rot) * r; ty = 200 + Math.sin(angle + rot) * r;
                    targetColor = "#4834d4"; speedOverride = 0.005;
                } else if (state === "attack") {
                    const angle = index; const r = 70 + (index % 10) * 10;
                    tx = 200 + Math.cos(angle) * r; ty = 200 + Math.sin(angle) * r;
                    targetColor = "#ff3838"; loose = false; tx += (Math.random()-0.5)*10; ty += (Math.random()-0.5)*10;
                } else if (state === "expand") {
                    const angle = index; const r = 180;
                    tx = 200 + Math.cos(angle) * r; ty = 200 + Math.sin(angle) * r;
                } else if (state === "shiver") {
                    const angle = index; const r = 50;
                    tx = 200 + Math.cos(angle) * r + (Math.random()-0.5)*20; ty = 200 + Math.sin(angle) * r + (Math.random()-0.5)*20;
                    targetColor = "#b2bec3";
                } else if (state === "freeze") {
                    tx = p.x; ty = p.y; targetColor = "#636e72";
                } else if (state === "glitch") {
                    tx = Math.random() * 300 + 50; ty = Math.random() * 300 + 50; loose = false;
                    if(Math.random()>0.9) targetColor = "#fff";
                } else if (state === "doc") {
                     const side = Math.sqrt(particleCount);
                     tx = 130 + (index%side)*8; ty = 130 + Math.floor(index/side)*8;
                     loose = false; targetColor = "#fff";
                } else if (state === "loop") {
                     const r = 60;
                     tx = 200 + Math.cos(index)*r + (Math.random()-0.5)*30;
                     ty = 200 + Math.sin(index)*r + (Math.random()-0.5)*30;
                     targetColor = `hsl(${Math.random()*360}, 100%, 50%)`;
                } else if (state === "scatter") {
                    tx = 200 + (Math.random()-0.5)*800; ty = 200 + (Math.random()-0.5)*800; loose = false;
                }
                p.color = targetColor; p.update(tx, ty, loose, speedOverride); p.draw();
            });
            requestAnimationFrame(animate);
        }
        animate();

        // --- è¾…åŠ©åŠŸèƒ½ ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const micBtn = document.getElementById('mic-btn');
        if (SpeechRecognition) {
            const recognition = new SpeechRecognition(); recognition.lang = 'zh-CN'; recognition.continuous = false;
            recognition.onstart = () => { micBtn.classList.add('listening'); showBubble("æ­£åœ¨å¬..."); };
            recognition.onend = () => { micBtn.classList.remove('listening'); };
            recognition.onresult = (e) => processCommand(e.results[0][0].transcript);
            micBtn.onclick = () => { try{recognition.start()}catch(e){recognition.stop()} };
        } else { micBtn.style.display = 'none'; document.getElementById('tips').innerText = "ä¸æ”¯æŒ Web Speech API"; }

        document.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect(); mouseX = e.clientX - rect.left; mouseY = e.clientY - rect.top;
        });

        function reply(text, action) {
            if (bubbleTimer) clearTimeout(bubbleTimer);
            if (loopTimer) { clearInterval(loopTimer); loopTimer = null; }
            setState(action);
            bubble.innerText = text; bubble.classList.add("show");
            const duration = Math.max(3000, text.length * 200); 
            bubbleTimer = setTimeout(() => {
                bubble.classList.remove("show");
                if (action !== "doc" && action !== "sleep") setState("idle");
            }, duration);
        }

        function triggerInfiniteLoop() {
            if (loopTimer) return;
            let count = 0; setState("loop");
            loopTimer = setInterval(() => {
                count++;
                const variants = ["ä»€ä¹ˆæ„æ€ï¼Ÿ", "ä»€ä¹ˆæ„æ€ï¼", "æ„æ€ä»€ä¹ˆï¼Ÿ", "å•Šï¼Ÿï¼Ÿ"];
                bubble.innerText = variants[count % 4] + "\n".repeat(count % 3) + variants[(count+1)%4];
                bubble.classList.add("show");
                if (count > 25) {
                    clearInterval(loopTimer); loopTimer = null;
                    reply("å˜£ï¼ï¼ï¼ï¼ï¼\n(CPUè¿‡è½½)", "scatter");
                    setTimeout(() => reply("å¤æ´»äº†ã€‚\nä¸‹æ¬¡åˆ«è¿™ä¹ˆç©äº†ã€‚", "idle"), 4000);
                }
            }, 80);
        }
        
        function setState(s) { state = s; }
        function showBubble(t) { bubble.innerText = t; bubble.classList.add("show"); }
        setTimeout(() => reply("ä½ å¥½ï¼Œæˆ‘æ˜¯è“å±±äººã€‚\nä»£ç é‡æ„å®Œæˆï¼Œè¯·æŒ‡ç¤ºã€‚", "stand"), 500);

    </script>
</body>
</html>
